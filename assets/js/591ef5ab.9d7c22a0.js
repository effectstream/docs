"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[3673],{2852:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"home/components/batcher/introduction","title":"Introduction","description":"Welcome to the Batcher, a powerful and flexible service designed to solve the complex problem of transaction batching in a multi-chain environment.","source":"@site/docs/home/100-components/108-batcher/1210-introduction.md","sourceDirName":"home/100-components/108-batcher","slug":"/home/components/batcher/introduction","permalink":"/docs/home/components/batcher/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/108-batcher/1210-introduction.md","tags":[],"version":"current","sidebarPosition":1210,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/docs/home/components/batcher/overview"},"next":{"title":"Core Concepts","permalink":"/docs/home/components/batcher/core-concepts"}}');var a=n(2531),c=n(6613);const r={},o="Introduction",s={},l=[{value:"What is the Batcher?",id:"what-is-the-batcher",level:2},{value:"The Core Problem: Multi-Chain Abstraction",id:"the-core-problem-multi-chain-abstraction",level:2},{value:"Adapter-Driven Architecture",id:"adapter-driven-architecture",level:3}];function h(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,a.jsx)(i.p,{children:"Welcome to the Batcher, a powerful and flexible service designed to solve the complex problem of transaction batching in a multi-chain environment."}),"\n",(0,a.jsx)(i.h2,{id:"what-is-the-batcher",children:"What is the Batcher?"}),"\n",(0,a.jsx)(i.p,{children:"The Batcher is a standalone service that acts as a robust, chain-agnostic ingestion point for user inputs. Its primary job is to:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Receive inputs via a simple HTTP API."}),"\n",(0,a.jsx)(i.li,{children:"Validate these inputs using chain-specific logic."}),"\n",(0,a.jsx)(i.li,{children:"Queue and collect valid inputs."}),"\n",(0,a.jsx)(i.li,{children:"Batch them into a single, optimized transaction."}),"\n",(0,a.jsx)(i.li,{children:"Submit that transaction to the target blockchain."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"This service abstracts away the complexity of managing private keys, nonces, gas fees, and transaction confirmation logic, providing your application with a single, reliable endpoint for submitting data."}),"\n",(0,a.jsx)(i.h2,{id:"the-core-problem-multi-chain-abstraction",children:"The Core Problem: Multi-Chain Abstraction"}),"\n",(0,a.jsx)(i.p,{children:"In a multi-chain application (e.g., one that interacts with both an EVM chain and Midnight), batching logic is notoriously difficult. Each chain has a different:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Input format (e.g., EVM function calls vs. Midnight circuit arguments)."}),"\n",(0,a.jsx)(i.li,{children:"Transaction building process."}),"\n",(0,a.jsx)(i.li,{children:"Signature verification method."}),"\n",(0,a.jsx)(i.li,{children:"Transaction Confirmation and receipt-handling mechanism."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Writing a single service that can handle all of this is complex and error-prone."}),"\n",(0,a.jsx)(i.h3,{id:"adapter-driven-architecture",children:"Adapter-Driven Architecture"}),"\n",(0,a.jsx)(i.p,{children:"The Batcher solves this problem with a flexible, plugin-based architecture. The core batcher service itself knows nothing about any specific blockchain."}),"\n",(0,a.jsxs)(i.p,{children:["Instead, all chain-specific logic is delegated to a ",(0,a.jsx)(i.code,{children:"BlockchainAdapter"}),". A ",(0,a.jsx)(i.code,{children:"BlockchainAdapter"}),' is a "driver" you provide for a specific chain target (e.g., ',(0,a.jsx)(i.code,{children:'"evm"'})," or ",(0,a.jsx)(i.code,{children:'"midnight"'}),"). This adapter is responsible for all chain-specific tasks:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Validating an input's data structure."}),"\n",(0,a.jsx)(i.li,{children:"Verifying a user's signature."}),"\n",(0,a.jsx)(i.li,{children:"Building a valid batch payload from a list of inputs."}),"\n",(0,a.jsx)(i.li,{children:"Submitting the final transaction to the node."}),"\n",(0,a.jsx)(i.li,{children:"Waiting for the transaction to be confirmed."}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["This design (seen in ",(0,a.jsx)(i.code,{children:"adapter.ts"})," and implemented in ",(0,a.jsx)(i.code,{children:"paimal2-adapter.ts"})," and ",(0,a.jsx)(i.code,{children:"midnight-adapter.ts"}),") means the core batcher simply orchestrates the flow, making the system incredibly flexible. To add support for a new chain, you simply write a new adapter\u2014no need to modify the batcher's core logic."]})]})}function d(e={}){const{wrapper:i}={...(0,c.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},6613:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>o});var t=n(1491);const a={},c=t.createContext(a);function r(e){const i=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(c.Provider,{value:i},e.children)}}}]);