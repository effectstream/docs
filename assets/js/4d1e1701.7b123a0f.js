"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[4384],{6613:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(1491);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}},8741:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"home/components/grammar","title":"Grammar","description":"The Grammar is the formal \\"language\\" of your Paima application. It acts as a crucial bridge, defining a strict, type-safe structure for all on-chain inputs and connecting them directly to your State Machine.","source":"@site/docs/home/100-components/111-grammar.md","sourceDirName":"home/100-components","slug":"/home/components/grammar","permalink":"/paima-v-next-docs/home/components/grammar","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/111-grammar.md","tags":[],"version":"current","sidebarPosition":111,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Logs","permalink":"/paima-v-next-docs/home/components/logs"},"next":{"title":"Wallets","permalink":"/paima-v-next-docs/home/components/wallets"}}');var a=t(2531),i=t(6613);const s={},o="Grammar",c={},l=[{value:"Defining Your Grammar",id:"defining-your-grammar",level:2},{value:"Anatomy of a Grammar Rule",id:"anatomy-of-a-grammar-rule",level:3},{value:"Automating Grammar for Primitives",id:"automating-grammar-for-primitives",level:2},{value:"How Grammar Connects to the State Machine",id:"how-grammar-connects-to-the-state-machine",level:2},{value:"Built-in System Grammar (<code>&amp;</code>)",id:"built-in-system-grammar-",level:2},{value:"Batched Inputs: <code>&amp;B</code>",id:"batched-inputs-b",level:4},{value:"Account Management Commands",id:"account-management-commands",level:3},{value:"Creating Inputs on the Frontend",id:"creating-inputs-on-the-frontend",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"grammar",children:"Grammar"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"Grammar"}),' is the formal "language" of your Paima application. It acts as a crucial bridge, defining a strict, type-safe structure for all on-chain inputs and connecting them directly to your ',(0,a.jsx)(n.a,{href:"/paima-v-next-docs/home/components/state-machine",children:"State Machine"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Its primary responsibilities are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Defining Structure"}),": It specifies the exact format for every valid command your application can receive."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation"}),": It ensures that incoming data is well-formed before it ever reaches your application logic."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parsing"}),": It transforms raw on-chain data into type-safe, structured JavaScript objects for your State Transition Functions (STFs)."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Paima v2 uses a structured ",(0,a.jsx)(n.strong,{children:"JSON array format"})," for all inputs."]}),"\n",(0,a.jsx)(n.h2,{id:"defining-your-grammar",children:"Defining Your Grammar"}),"\n",(0,a.jsxs)(n.p,{children:["In ",(0,a.jsx)(n.code,{children:"/templates/evm-examples/"})," example ",(0,a.jsx)(n.code,{children:"grammar.ts"})]}),"\n",(0,a.jsxs)(n.p,{children:["You define your application's grammar in a single ",(0,a.jsx)(n.code,{children:"grammar.ts"})," file. This is a TypeScript object where each key represents a command's ",(0,a.jsx)(n.strong,{children:"prefix"}),", and the value defines the structure of its expected arguments."]}),"\n",(0,a.jsx)(n.p,{children:"The prefix is always the first element in an input's JSON array and is used by the engine to route the input to the correct grammar rule and, subsequently, the correct STF."}),"\n",(0,a.jsx)(n.h3,{id:"anatomy-of-a-grammar-rule",children:"Anatomy of a Grammar Rule"}),"\n",(0,a.jsxs)(n.p,{children:["Let's look at a simple rule for an ",(0,a.jsx)(n.code,{children:"attack"})," command."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Type } from "@sinclair/typebox";\nimport { type GrammarDefinition } from "@paima/concise";\n\nexport const grammar = {\n  // The command\'s prefix is "attack"\n  attack: [\n    // This defines the expected arguments that follow the prefix.\n    ["playerId", Type.Integer()],\n    ["moveId", Type.Integer()],\n  ],\n  // ... other rules\n} as const satisfies GrammarDefinition;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This rule defines that a valid ",(0,a.jsx)(n.code,{children:"attack"})," input must be a JSON array structured like this: ",(0,a.jsx)(n.code,{children:'["attack", <number>, <number>]'}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Each argument is defined as a tuple ",(0,a.jsx)(n.code,{children:"[name, type]"}),":"]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Element"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,a.jsx)(n.code,{children:"name"})," (string)"]}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"The name of the argument. This becomes the key in the parsed object available in your STF."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,a.jsx)(n.code,{children:"type"})," (TypeBox Schema)"]}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["A schema from ",(0,a.jsx)(n.strong,{children:"TypeBox"})," that defines the data type and constraints for the argument. The engine uses this to validate the input and provide type safety."]})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"automating-grammar-for-primitives",children:"Automating Grammar for Primitives"}),"\n",(0,a.jsxs)(n.p,{children:["You don't have to define grammar rules for every on-chain event manually. To save time, Effectstream provides the ",(0,a.jsx)(n.code,{children:"mapPrimitivesToGrammar"})," helper function. This function automatically inspects the ",(0,a.jsx)(n.strong,{children:"Primitives"})," you've defined in your ",(0,a.jsx)(n.a,{href:"/paima-v-next-docs/home/components/sync-service",children:"Sync Service Config"})," and generates the corresponding grammar rules for you."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, if you have a primitive tracking an ERC20 ",(0,a.jsx)(n.code,{children:"Transfer(address from, address to, uint256 value)"})," event with the scheduled prefix ",(0,a.jsx)(n.code,{children:"transfer"}),", this helper will create a ",(0,a.jsx)(n.code,{children:"transfer"})," grammar rule that expects a payload object with ",(0,a.jsx)(n.code,{children:"from"}),", ",(0,a.jsx)(n.code,{children:"to"}),", and ",(0,a.jsx)(n.code,{children:"value"})," fields."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { mapPrimitivesToGrammar } from "@paima/concise";\nimport { localhostConfig } from "./config.ts";\n\nexport const grammar = {\n  // Your custom, application-specific commands\n  attack: [\n    ["playerId", Type.Integer()],\n    ["moveId", Type.Integer()],\n  ],\n\n  // Automatically generate grammar rules from all configured primitives\n  ...mapPrimitivesToGrammar(localhostConfig.primitives)\n\n} as const satisfies GrammarDefinition;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"how-grammar-connects-to-the-state-machine",children:"How Grammar Connects to the State Machine"}),"\n",(0,a.jsx)(n.p,{children:"The grammar is the central piece that links an on-chain event to your application logic. Here\u2019s the flow:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"On-Chain Input"}),": A transaction is sent to the ",(0,a.jsx)(n.code,{children:"PaimaL2Contract"})," with a payload that is a JSON-stringified array, e.g., ",(0,a.jsx)(n.code,{children:'"[\\"attack\\",1,42]"'}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prefix Matching"}),": The Effectstream parses the JSON and inspects the first element (",(0,a.jsx)(n.code,{children:'"attack"'}),") to find the matching rule in your ",(0,a.jsx)(n.code,{children:"grammar.ts"})," file."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parsing & Validation"}),": It then uses the TypeBox schemas defined in that rule (",(0,a.jsx)(n.code,{children:"Type.Integer()"}),", ",(0,a.jsx)(n.code,{children:"Type.Integer()"}),") to validate and parse the remaining elements (",(0,a.jsx)(n.code,{children:"1"}),", ",(0,a.jsx)(n.code,{children:"42"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"STF Execution"}),": Finally, the engine calls the STF registered with the prefix ",(0,a.jsx)(n.code,{children:'"attack"'}),", passing it a ",(0,a.jsx)(n.code,{children:"data"})," object containing the fully typed and parsed input:","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// In your STF, data.parsedInput would look like this:\n{\n    playerId: 1,\n    moveId: 42\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"built-in-system-grammar-",children:["Built-in System Grammar (",(0,a.jsx)(n.code,{children:"&"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Effectstream reserves the ",(0,a.jsx)(n.code,{children:"&"})," prefix for a suite of powerful, built-in system commands. You do not need to define these in your grammar file; the engine handles them automatically."]}),"\n",(0,a.jsxs)(n.h4,{id:"batched-inputs-b",children:["Batched Inputs: ",(0,a.jsx)(n.code,{children:"&B"})]}),"\n",(0,a.jsxs)(n.p,{children:["This command allows multiple user inputs to be bundled into a single on-chain transaction. This is the primary mechanism used by the ",(0,a.jsx)(n.strong,{children:"Batcher"})," service to provide a gas-efficient and cross-chain experience."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logical Structure"}),": ",(0,a.jsx)(n.code,{children:'["&B", [input1, input2, ...]]'})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameters"}),": The second element is an array of other valid Paima inputs."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Robustness"}),": If any individual input within the batch is malformed, the engine will skip it and continue processing the rest, preventing a single error from halting the entire batch."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"account-management-commands",children:"Account Management Commands"}),"\n",(0,a.jsx)(n.p,{children:"These commands provide a flexible L2 Account Abstraction system, allowing multiple wallets to control a single Paima account."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"&createAccount"})}),": Creates a new Paima Account, with the sender becoming the primary wallet.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Structure"}),": ",(0,a.jsx)(n.code,{children:'["&createAccount"]'})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"&linkAddress"})}),": Links a new wallet to an existing account, requiring signatures from both the primary and new wallets.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Structure"}),": ",(0,a.jsx)(n.code,{children:'["&linkAddress", account_id, signature_from_primary, primary_address_type, new_address, signature_from_new_address, signature_from_new_address, is_new_primary]'})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"&unlinkAddress"})}),": Removes a wallet from an account.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Structure"}),": ",(0,a.jsx)(n.code,{children:'["&unlinkAddress", account_id, signature_from_primary, primary_address_type, address_to_unlink, new_primary_if_needed]'})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"creating-inputs-on-the-frontend",children:"Creating Inputs on the Frontend"}),"\n",(0,a.jsx)(n.p,{children:"On the frontend, you simply construct a standard JavaScript array and then JSON-stringify it to create the payload for a transaction."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// 1. Create the move as a JavaScript array\nconst move = ["attack", 1, 42];\n\n// 2. Stringify it to create the payload\nconst payload = JSON.stringify(move);\n\n// 3. Submit the payload to the PaimaL2Contract\n// (The frontend SDKs will handle this for you)\nawait paimaL2Contract.submitInput(payload);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);