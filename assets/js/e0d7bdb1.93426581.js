"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[8846],{6613:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>c});var i=t(1491);const a={},r=i.createContext(a);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:e},n.children)}},7221:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"home/components/batcher/adapter","title":"Custom Adapters","description":"Overview","source":"@site/docs/home/100-components/108-batcher/1250-adapter.md","sourceDirName":"home/100-components/108-batcher","slug":"/home/components/batcher/adapter","permalink":"/docs/home/components/batcher/adapter","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/108-batcher/1250-adapter.md","tags":[],"version":"current","sidebarPosition":1250,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/docs/home/components/batcher/configuration"},"next":{"title":"Advanced Topics","permalink":"/docs/home/components/batcher/advanced-topics"}}');var a=t(2531),r=t(6613);const s={},c="Custom Adapters",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Target Audience",id:"target-audience",level:2},{value:"The <code>BlockchainAdapter&lt;TOutput&gt;</code> Interface",id:"the-blockchainadaptertoutput-interface",level:2},{value:"Generic Type Parameter: <code>TOutput</code>",id:"generic-type-parameter-toutput",level:3},{value:"Implementing Adapter Methods",id:"implementing-adapter-methods",level:2},{value:"1. <code>validateInput()</code> \u2013 Pre-Queue Validation (Optional)",id:"1-validateinput--pre-queue-validation-optional",level:3},{value:"2. <code>verifySignature()</code> \u2013 Authentication (Optional)",id:"2-verifysignature--authentication-optional",level:3},{value:"3. <code>buildBatchData()</code> \u2013 Serialization",id:"3-buildbatchdata--serialization",level:3},{value:"Approach A: Use a Helper Class (Recommended for Standard Formats)",id:"approach-a-use-a-helper-class-recommended-for-standard-formats",level:4},{value:"Approach B: Implement Custom Logic",id:"approach-b-implement-custom-logic",level:4},{value:"4. <code>submitBatch()</code> \u2013 Execution",id:"4-submitbatch--execution",level:3},{value:"5. <code>waitForTransactionReceipt()</code> \u2013 Confirmation",id:"5-waitfortransactionreceipt--confirmation",level:3},{value:"6. <code>estimateBatchFee()</code> \u2013 Fee Estimation",id:"6-estimatebatchfee--fee-estimation",level:3},{value:"Approach A: Static Fee (Simplest)",id:"approach-a-static-fee-simplest",level:4},{value:"Approach B: Gas Estimation (EVM)",id:"approach-b-gas-estimation-evm",level:4},{value:"Approach C: Zero Fee (Chain-Specific)",id:"approach-c-zero-fee-chain-specific",level:4},{value:"7. Metadata Methods",id:"7-metadata-methods",level:3},{value:"<code>getAccountAddress()</code>",id:"getaccountaddress",level:4},{value:"<code>getChainName()</code>",id:"getchainname",level:4},{value:"<code>getSyncProtocolName()</code> (Optional)",id:"getsyncprotocolname-optional",level:4},{value:"<code>isReady()</code>",id:"isready",level:4},{value:"<code>getBlockNumber()</code>",id:"getblocknumber",level:4},{value:"Helper Classes for Batch Serialization",id:"helper-classes-for-batch-serialization",level:2},{value:"<code>DefaultBatchBuilderLogic</code>",id:"defaultbatchbuilderlogic",level:3},{value:"<code>MidnightBatchBuilderLogic</code>",id:"midnightbatchbuilderlogic",level:3},{value:"Complete Adapter Examples",id:"complete-adapter-examples",level:2},{value:"Example 1: ERC1155CustomAdapter (Using Helper)",id:"example-1-erc1155customadapter-using-helper",level:3},{value:"Example 2: MidnightAdapter (Using Helper)",id:"example-2-midnightadapter-using-helper",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"custom-adapters",children:"Custom Adapters"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"BlockchainAdapter"})," interface is the core extension point for supporting new blockchains in the Batcher. By implementing this interface, you can integrate any blockchain\u2014whether EVM-based, zero-knowledge chains like Midnight, or custom Layer 2 solutions\u2014into the unified batching pipeline."]}),"\n",(0,a.jsx)(e.p,{children:"This guide walks you through:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Understanding the ",(0,a.jsx)(e.code,{children:"BlockchainAdapter<TOutput>"})," interface"]}),"\n",(0,a.jsx)(e.li,{children:"Implementing each method with direct links to the pipeline"}),"\n",(0,a.jsx)(e.li,{children:"Using optional helper classes for batch serialization"}),"\n",(0,a.jsx)(e.li,{children:"Real-world examples (ERC1155 and Midnight adapters)"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"target-audience",children:"Target Audience"}),"\n",(0,a.jsx)(e.p,{children:"Developers who need to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Support a new blockchain in the Batcher"}),"\n",(0,a.jsx)(e.li,{children:"Customize batch submission logic for specialized contracts"}),"\n",(0,a.jsx)(e.li,{children:"Implement chain-specific validation or signature schemes"}),"\n",(0,a.jsx)(e.li,{children:"Override default batching behavior"}),"\n"]}),"\n",(0,a.jsxs)(e.h2,{id:"the-blockchainadaptertoutput-interface",children:["The ",(0,a.jsx)(e.code,{children:"BlockchainAdapter<TOutput>"})," Interface"]}),"\n",(0,a.jsxs)(e.p,{children:["The adapter interface is generic over ",(0,a.jsx)(e.code,{children:"TOutput"}),", which represents the ",(0,a.jsx)(e.strong,{children:"type of your serialized batch payload"}),". This flexibility allows each adapter to use the most appropriate data format for its blockchain."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface BlockchainAdapter<TOutput> {\n  // Core batch operations\n  buildBatchData(inputs, options?): BatchBuildingResult<TOutput> | null;\n  submitBatch(data: TOutput, fee): Promise<BlockchainHash>;\n  waitForTransactionReceipt(hash, timeout?): Promise<BlockchainTransactionReceipt>;\n  estimateBatchFee(data: TOutput): Promise<string | bigint> | string | bigint;\n  \n  // Validation hooks (optional)\n  verifySignature?(input): boolean | Promise<boolean>;\n  validateInput?(input): ValidationResult | Promise<ValidationResult>;\n  \n  // Metadata and state\n  getAccountAddress(): string;\n  getChainName(): string;\n  getSyncProtocolName?(): string;\n  isReady(): boolean;\n  getBlockNumber(): Promise<bigint>;\n  \n  // Optional batch size constraint (in bytes)\n  maxBatchSize?: number;\n}\n"})}),"\n",(0,a.jsxs)(e.h3,{id:"generic-type-parameter-toutput",children:["Generic Type Parameter: ",(0,a.jsx)(e.code,{children:"TOutput"})]}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"TOutput"})," parameter defines what ",(0,a.jsx)(e.code,{children:"buildBatchData()"})," produces and what ",(0,a.jsx)(e.code,{children:"submitBatch()"})," consumes:"]}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Blockchain Type"}),(0,a.jsxs)(e.th,{children:[(0,a.jsx)(e.code,{children:"TOutput"})," Example"]}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.strong,{children:"EVM (PaimaL2)"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"string"})}),(0,a.jsxs)(e.td,{children:["JSON string like ",(0,a.jsx)(e.code,{children:'["&B", [...]]'})]})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.strong,{children:"Midnight"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"MidnightBatchPayload"})}),(0,a.jsx)(e.td,{children:"Structured object with circuit args"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.strong,{children:"Custom Chain"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Uint8Array"})}),(0,a.jsx)(e.td,{children:"Raw bytes for binary protocols"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.strong,{children:"Solana"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Transaction"})}),(0,a.jsx)(e.td,{children:"Native transaction object"})]})]})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Insight"}),": The format is arbitrary. The only requirement is that your ",(0,a.jsx)(e.code,{children:"submitBatch()"})," method knows how to parse what your ",(0,a.jsx)(e.code,{children:"buildBatchData()"})," method creates."]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"implementing-adapter-methods",children:"Implementing Adapter Methods"}),"\n",(0,a.jsxs)(e.p,{children:["Each method in the interface maps to a specific step in the ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline",children:"batching pipeline"}),". Let's walk through them in order."]}),"\n",(0,a.jsxs)(e.h3,{id:"1-validateinput--pre-queue-validation-optional",children:["1. ",(0,a.jsx)(e.code,{children:"validateInput()"})," \u2013 Pre-Queue Validation (Optional)"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#3b-input-validation",children:"Step 3b: Input Validation"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Validate inputs ",(0,a.jsx)(e.strong,{children:"before"})," they enter persistent storage. This prevents invalid data from polluting your queue."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"validateInput?(input: DefaultBatcherInput): ValidationResult | Promise<ValidationResult>\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"When to Implement:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Your chain requires specific input formats (e.g., circuit arguments for zero-knowledge chains)"}),"\n",(0,a.jsx)(e.li,{children:"You need to validate payload structure before storage"}),"\n",(0,a.jsx)(e.li,{children:"You want to fail fast on malformed inputs"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: ERC1155 Adapter"})}),"\n",(0,a.jsxs)(e.p,{children:["The ERC1155 adapter validates function calls for ",(0,a.jsx)(e.code,{children:"mint()"})," and ",(0,a.jsx)(e.code,{children:"transferToMidnight()"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'validateInput(input: DefaultBatcherInput): ValidationResult {\n  try {\n    // Parse the function call from input.input field\n    const functionCall = this.parseFunctionCall(input.input);\n    \n    switch (functionCall.function) {\n      case "mint":\n        if (functionCall.args.length !== 2) {\n          return {\n            valid: false,\n            error: `mint() expects 2 arguments (address, amount), got ${functionCall.args.length}`\n          };\n        }\n        break;\n        \n      case "transferToMidnight":\n        if (functionCall.args.length !== 3) {\n          return {\n            valid: false,\n            error: `transferToMidnight() expects 3 arguments (amount, targetAddress, txHash), got ${functionCall.args.length}`\n          };\n        }\n        break;\n        \n      default:\n        return {\n          valid: false,\n          error: `Unsupported function: ${functionCall.function}. Supported: mint, transferToMidnight`\n        };\n    }\n    \n    return { valid: true };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : "Unknown validation error"\n    };\n  }\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: Midnight Adapter"})}),"\n",(0,a.jsx)(e.p,{children:"The Midnight adapter validates circuit arguments:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'validateInput(input: DefaultBatcherInput): ValidationResult {\n  try {\n    // Decode input (might be hex-encoded)\n    const decodedInput = this.decodeHexIfNeeded(input.input);\n    \n    // Parse circuit invocation\n    const parsed = JSON.parse(decodedInput);\n    \n    if (!parsed || typeof parsed.circuit !== "string" || !Array.isArray(parsed.args)) {\n      return {\n        valid: false,\n        error: "Invalid input structure. Expected { circuit: string, args: [] }"\n      };\n    }\n    \n    // Check circuit exists in contract\n    const circuitDef = this.contractInfo.circuits.find(c => c.name === parsed.circuit);\n    if (!circuitDef) {\n      return {\n        valid: false,\n        error: `Circuit "${parsed.circuit}" not found. Available: ${\n          this.contractInfo.circuits.map(c => c.name).join(", ")\n        }`\n      };\n    }\n    \n    // Validate circuit arguments structure\n    parseCircuitArgs(parsed.circuit, parsed.args, this.contractInfo);\n    \n    return { valid: true };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : "Unknown validation error"\n    };\n  }\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{title:"When to Skip Validation",type:"tip",children:(0,a.jsx)(e.p,{children:"If your blockchain accepts any input format and validation happens on-chain, you can omit this method. The batcher will accept all inputs that pass signature verification."})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.h3,{id:"2-verifysignature--authentication-optional",children:["2. ",(0,a.jsx)(e.code,{children:"verifySignature()"})," \u2013 Authentication (Optional)"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#3a-signature-verification",children:"Step 3a: Signature Verification"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Verify cryptographic signatures to ensure inputs are authentic."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"verifySignature?(input: DefaultBatcherInput): boolean | Promise<boolean>\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Default Behavior:"})," If not implemented, the batcher uses EVM signature verification via ",(0,a.jsx)(e.code,{children:"CryptoManager.Evm().verifySignature()"}),"."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"When to Override:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Your blockchain doesn't use traditional signatures (e.g., Midnight uses circuit-based proofs)"}),"\n",(0,a.jsx)(e.li,{children:"You need custom signature schemes (e.g., multi-sig, threshold signatures)"}),"\n",(0,a.jsx)(e.li,{children:"Signatures are verified on-chain and you want to skip client-side verification"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: Midnight Adapter (Bypass Signatures)"})}),"\n",(0,a.jsx)(e.p,{children:"Midnight uses zero-knowledge circuits instead of traditional signatures:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"verifySignature(input: DefaultBatcherInput): boolean {\n  // Midnight inputs use circuit-based validation, not signatures\n  // The adapter/contract is responsible for authentication\n  return true;  // Bypass signature check\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: Custom Multi-Sig Adapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async verifySignature(input: DefaultBatcherInput): Promise<boolean> {\n  // Expect signature to contain multiple signatures\n  const signatures = JSON.parse(input.signature);\n  \n  if (!Array.isArray(signatures) || signatures.length < this.requiredSignatures) {\n    return false;\n  }\n  \n  // Verify each signature\n  for (const sig of signatures) {\n    const isValid = await this.cryptoManager.verifySignature(\n      input.address,\n      input.input,\n      sig,\n      input.timestamp\n    );\n    if (!isValid) return false;\n  }\n  \n  return true;\n}\n"})}),"\n",(0,a.jsx)(e.admonition,{title:"Signature Verification is Critical",type:"warning",children:(0,a.jsxs)(e.p,{children:["If you return ",(0,a.jsx)(e.code,{children:"true"})," unconditionally, ",(0,a.jsx)(e.strong,{children:"any input will pass authentication"}),". Only do this if your blockchain has alternative authentication mechanisms (like circuit proofs) or if signature verification happens on-chain."]})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.h3,{id:"3-buildbatchdata--serialization",children:["3. ",(0,a.jsx)(e.code,{children:"buildBatchData()"})," \u2013 Serialization"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#step-6-building-adapter-driven",children:"Step 6: Building"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Transform an array of ",(0,a.jsx)(e.code,{children:"DefaultBatcherInput"})," into a single ",(0,a.jsx)(e.code,{children:"TOutput"})," payload that your blockchain can consume."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"buildBatchData(\n  inputs: DefaultBatcherInput[],\n  options?: BatchBuildingOptions\n): BatchBuildingResult<TOutput> | null\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Type:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface BatchBuildingResult<TOutput> {\n  selectedInputs: DefaultBatcherInput[];  // Inputs included in this batch\n  data: TOutput;                           // Serialized batch payload\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Key Responsibilities:"})}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Serialize"})," inputs into your blockchain's expected format"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Respect size limits"})," via ",(0,a.jsx)(e.code,{children:"options.maxSize"})," or ",(0,a.jsx)(e.code,{children:"this.maxBatchSize"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Select inputs"})," that fit within the size constraint"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Return remaining inputs"})," (they'll be processed in the next batch)"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Two Approaches:"})}),"\n",(0,a.jsx)(e.h4,{id:"approach-a-use-a-helper-class-recommended-for-standard-formats",children:"Approach A: Use a Helper Class (Recommended for Standard Formats)"}),"\n",(0,a.jsx)(e.p,{children:"If your blockchain uses a standard format (like Paima's JSON batching format), use a helper class:"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: PaimaL2DefaultAdapter (EVM)"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'export class PaimaL2DefaultAdapter implements BlockchainAdapter<string> {\n  private readonly batchBuilderLogic = new DefaultBatchBuilderLogic();\n  \n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<string> | null {\n    // Delegate to helper that produces: ["&B", [input1, input2, ...]]\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"DefaultBatchBuilderLogic"})," produces:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'["&B", [\n  ["0", "0x742d35Cc...", "0xsig1...", "move|x10y20", "1234567890"],\n  ["0", "0xabc123...", "0xsig2...", "attack|id5", "1234567891"]\n]]\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: MidnightAdapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"export class MidnightAdapter implements BlockchainAdapter<MidnightBatchPayload | null> {\n  private readonly batchBuilderLogic = new MidnightBatchBuilderLogic();\n  \n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<MidnightBatchPayload | null> | null {\n    // Delegate to helper that produces structured circuit args\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"MidnightBatchBuilderLogic"})," produces:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'{\n  prefix: "&B",\n  payloads: [\n    {\n      circuit: "transferBatch",\n      args: [100n, "0xabc..."],\n      addressType: 0,\n      address: "0x742d35Cc...",\n      signature: "...",\n      timestamp: "1234567890"\n    }\n  ]\n}\n'})}),"\n",(0,a.jsx)(e.h4,{id:"approach-b-implement-custom-logic",children:"Approach B: Implement Custom Logic"}),"\n",(0,a.jsx)(e.p,{children:"For unique blockchain requirements, implement serialization directly:"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: Binary Protocol Adapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"export class BinaryProtocolAdapter implements BlockchainAdapter<Uint8Array> {\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<Uint8Array> | null {\n    if (inputs.length === 0) return null;\n    \n    const maxSize = options?.maxSize ?? this.maxBatchSize ?? 10000;\n    const selectedInputs: DefaultBatcherInput[] = [];\n    const chunks: Uint8Array[] = [];\n    \n    let currentSize = 4; // 4-byte header for input count\n    \n    for (const input of inputs) {\n      // Serialize each input to binary format\n      const serialized = this.serializeInput(input);\n      \n      if (currentSize + serialized.length > maxSize) {\n        break; // Size limit reached\n      }\n      \n      chunks.push(serialized);\n      selectedInputs.push(input);\n      currentSize += serialized.length;\n    }\n    \n    if (chunks.length === 0) return null;\n    \n    // Combine all chunks into a single Uint8Array with header\n    const header = new Uint8Array(4);\n    new DataView(header.buffer).setUint32(0, chunks.length, false);\n    \n    const data = new Uint8Array(currentSize);\n    data.set(header, 0);\n    \n    let offset = 4;\n    for (const chunk of chunks) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n    \n    return { selectedInputs, data };\n  }\n  \n  private serializeInput(input: DefaultBatcherInput): Uint8Array {\n    // Custom binary serialization logic\n    // ...\n  }\n}\n"})}),"\n",(0,a.jsx)(e.admonition,{title:"Size Management",type:"tip",children:(0,a.jsxs)(e.p,{children:["Always respect ",(0,a.jsx)(e.code,{children:"options?.maxSize"})," or ",(0,a.jsx)(e.code,{children:"this.maxBatchSize"}),". If an input doesn't fit, ",(0,a.jsx)(e.strong,{children:"don't include it"}),"\u2014it will be processed in the next batch automatically."]})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.h3,{id:"4-submitbatch--execution",children:["4. ",(0,a.jsx)(e.code,{children:"submitBatch()"})," \u2013 Execution"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#step-7-submission-adapter-driven",children:"Step 7: Submission"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Submit the batch payload to your blockchain and return the transaction hash."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"submitBatch(data: TOutput, fee: string | bigint): Promise<BlockchainHash>\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Key Responsibilities:"})}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parse"})," the ",(0,a.jsx)(e.code,{children:"data"})," produced by ",(0,a.jsx)(e.code,{children:"buildBatchData()"}),". Some implementations just might want to send the received batched data withot parsing it."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Construct"})," a blockchain transaction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sign and submit"})," the transaction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Return"})," the transaction hash"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: PaimaL2DefaultAdapter (EVM)"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async submitBatch(data: string, fee?: string | bigint): Promise<BlockchainHash> {\n  let actualFee = this.paimaL2Fee;\n  if (fee) {\n    actualFee = typeof fee === "string" ? BigInt(fee) : fee;\n  }\n  \n  // Convert JSON string to hex bytes\n  const hexData = encodeHexFromString(data);\n  \n  // Submit to PaimaL2 contract\n  const hash = await this.walletClient.writeContract({\n    account: this.account,\n    chain: this.walletClient.chain,\n    address: this.paimaL2Address,\n    abi: this.paimaL2Abi,\n    functionName: "paimaSubmitGameInput",\n    args: [hexData],\n    value: actualFee,\n  });\n  \n  console.log(`\ud83d\ude80 Submitted batch transaction: ${hash}`);\n  return hash;\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: MidnightAdapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async submitBatch(\n  data: MidnightBatchPayload | null,\n  fee?: string | bigint\n): Promise<BlockchainHash> {\n  if (!data || !data.payloads || data.payloads.length === 0) {\n    throw new Error("Batch payload contained no invocations");\n  }\n  \n  // Midnight uses circuit invocations instead of raw transactions\n  const { circuit, args } = data.payloads[0];\n  \n  console.log(`\ud83d\udd04 Invoking circuit "${circuit}" with ${args.length} arguments`);\n  \n  // Parse circuit arguments\n  const parsedArgs = parseCircuitArgs(circuit, args, this.contractInfo);\n  \n  // Invoke the circuit via deployed contract\n  const result = await this.deployedContract.callTx[circuit](...parsedArgs);\n  \n  // Extract transaction hash from result\n  if (result && result.public && result.public.txHash) {\n    const txHash = result.public.txHash;\n    console.log(`\ud83d\ude80 Circuit invoked successfully! Transaction Hash: ${txHash}`);\n    return txHash;\n  }\n  \n  throw new Error("Transaction result format unexpected");\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: ERC1155CustomAdapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async submitBatch(data: string, fee?: string | bigint): Promise<BlockchainHash> {\n  // Parse the default batch format: ["&B", [input1, input2, ...]]\n  const batchArray = this.parseDefaultBatchFormat(data);\n  \n  if (batchArray.inputs.length === 0) {\n    throw new Error("Batch payload contained no inputs");\n  }\n  \n  // Extract first input: [addressType, address, signature, input, timestamp]\n  const firstInput = JSON.parse(batchArray.inputs[0] as string);\n  const inputData = firstInput[3]; // The \'input\' field\n  \n  // Parse function call: { "function": "mint", "args": [...] }\n  const functionCall = this.parseFunctionCall(inputData);\n  \n  let hash: string;\n  \n  // Route to appropriate contract function\n  switch (functionCall.function) {\n    case "mint": {\n      const [to, amount] = functionCall.args;\n      hash = await this.walletClient.writeContract({\n        account: this.account,\n        address: this.erc1155Address,\n        abi: mct_erc1155.abi,\n        functionName: "mint",\n        args: [to as `0x${string}`, BigInt(amount)],\n      });\n      break;\n    }\n    \n    case "transferToMidnight": {\n      const [amount, targetAddress, txHash] = functionCall.args;\n      hash = await this.walletClient.writeContract({\n        account: this.account,\n        address: this.erc1155Address,\n        abi: mct_erc1155.abi,\n        functionName: "transferToMidnight",\n        args: [BigInt(amount), targetAddress as `0x${string}`, txHash as `0x${string}`],\n      });\n      break;\n    }\n    \n    default:\n      throw new Error(`Unsupported function: ${functionCall.function}`);\n  }\n  \n  console.log(`\ud83d\ude80 Submitted transaction: ${hash}`);\n  return hash;\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{title:"Contract ABI Integration",type:"tip",children:(0,a.jsxs)(e.p,{children:["For EVM adapters, import your contract's ABI from ",(0,a.jsx)(e.code,{children:"@effectstream/evm-contracts"})," or your project's contract package. This provides type-safe contract interactions via viem."]})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.h3,{id:"5-waitfortransactionreceipt--confirmation",children:["5. ",(0,a.jsx)(e.code,{children:"waitForTransactionReceipt()"})," \u2013 Confirmation"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#step-8-confirmation-adapter-driven",children:"Step 8: Confirmation"})]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Wait for the blockchain to confirm the transaction and return a receipt."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"waitForTransactionReceipt(\n  hash: BlockchainHash,\n  timeout?: number\n): Promise<BlockchainTransactionReceipt>\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Return Type:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface BlockchainTransactionReceipt {\n  hash: BlockchainHash;\n  blockNumber: bigint;\n  status: number;  // 1 = success, 0 = failure\n  [key: string]: any;  // Additional chain-specific fields\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: EVM Adapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async waitForTransactionReceipt(\n  hash: BlockchainHash,\n  timeout?: number\n): Promise<BlockchainTransactionReceipt> {\n  const receipt = await this.publicClient.waitForTransactionReceipt({\n    hash: hash as Hash,\n    timeout,\n  });\n  \n  console.log(\n    `\u2705 Transaction confirmed! Block: ${receipt.blockNumber}, Hash: ${hash}, Status: ${receipt.status}`\n  );\n  \n  return {\n    hash: receipt.transactionHash,\n    blockNumber: receipt.blockNumber,\n    status: receipt.status === "success" ? 1 : 0,\n    _viemReceipt: receipt,  // Include original for EVM-specific access\n  };\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Example: Midnight Adapter"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async waitForTransactionReceipt(\n  hash: BlockchainHash,\n  timeout: number = 60000\n): Promise<BlockchainTransactionReceipt> {\n  console.log(`\u23f3 Waiting for transaction confirmation: ${hash}`);\n  \n  const startTime = Date.now();\n  \n  while (Date.now() - startTime < timeout) {\n    try {\n      const txInfo = await this.queryTransactionStatus(hash);\n      \n      if (txInfo && txInfo.confirmed) {\n        console.log(\n          `\u2705 Transaction confirmed! Block: ${txInfo.blockNumber}, Hash: ${hash}`\n        );\n        \n        return {\n          hash,\n          blockNumber: txInfo.blockNumber,\n          status: 1, // Success\n          _midnightTxInfo: txInfo,\n        };\n      }\n    } catch (error) {\n      console.warn(`Failed to query transaction status: ${error}`);\n    }\n    \n    // Wait before next poll\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }\n  \n  throw new Error(`Transaction confirmation timeout after ${timeout}ms`);\n}\n\nprivate async queryTransactionStatus(\n  txId: string\n): Promise<{ confirmed: boolean; blockNumber: bigint } | null> {\n  // Query indexer GraphQL API for transaction status\n  const query = `query ($hash: String!) {\n    transactions(offset: { hash: $hash }) {\n      applyStage\n      block { height }\n    }\n  }`;\n  \n  const response = await this.gqlQuery(query, { hash: txId });\n  \n  if (!response?.transactions?.[0]) return null;\n  \n  const tx = response.transactions[0];\n  const confirmed = tx.applyStage === "SucceedEntirely";\n  \n  return {\n    confirmed,\n    blockNumber: BigInt(tx.block.height),\n  };\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{title:"Timeout Handling",type:"tip",children:(0,a.jsx)(e.p,{children:"Always implement timeout logic. If a transaction is lost or the blockchain is stalled, you don't want the batcher to hang indefinitely."})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.h3,{id:"6-estimatebatchfee--fee-estimation",children:["6. ",(0,a.jsx)(e.code,{children:"estimateBatchFee()"})," \u2013 Fee Estimation"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Step:"})," ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline#step-7-submission-adapter-driven",children:"Step 7: Submission"})," (called before ",(0,a.jsx)(e.code,{children:"submitBatch"}),")"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Estimate the transaction fee for submitting a batch."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Signature:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"estimateBatchFee(data: TOutput): Promise<string | bigint> | string | bigint\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Common Approaches:"})}),"\n",(0,a.jsx)(e.h4,{id:"approach-a-static-fee-simplest",children:"Approach A: Static Fee (Simplest)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"estimateBatchFee(data: string): bigint {\n  return this.configuredFee;  // Return pre-configured fee\n}\n"})}),"\n",(0,a.jsx)(e.h4,{id:"approach-b-gas-estimation-evm",children:"Approach B: Gas Estimation (EVM)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async estimateBatchFee(data: string): Promise<bigint> {\n  const hexData = encodeHexFromString(data);\n  \n  const gasEstimate = await this.publicClient.estimateContractGas({\n    address: this.contractAddress,\n    abi: this.contractAbi,\n    functionName: "paimaSubmitGameInput",\n    args: [hexData],\n    account: this.account,\n  });\n  \n  const gasPrice = await this.publicClient.getGasPrice();\n  return gasEstimate * gasPrice;\n}\n'})}),"\n",(0,a.jsx)(e.h4,{id:"approach-c-zero-fee-chain-specific",children:"Approach C: Zero Fee (Chain-Specific)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"estimateBatchFee(data: MidnightBatchPayload | null): bigint {\n  // Midnight uses native token for fees, handled by wallet\n  return 0n;\n}\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"7-metadata-methods",children:"7. Metadata Methods"}),"\n",(0,a.jsx)(e.p,{children:"These methods provide information about the adapter's state and configuration."}),"\n",(0,a.jsx)(e.h4,{id:"getaccountaddress",children:(0,a.jsx)(e.code,{children:"getAccountAddress()"})}),"\n",(0,a.jsx)(e.p,{children:"Return the address that will submit transactions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"getAccountAddress(): string {\n  return this.account.address;  // EVM example\n}\n"})}),"\n",(0,a.jsx)(e.h4,{id:"getchainname",children:(0,a.jsx)(e.code,{children:"getChainName()"})}),"\n",(0,a.jsx)(e.p,{children:"Return a human-readable chain identifier:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'getChainName(): string {\n  return this.walletClient.chain?.name || "Unknown EVM Chain";\n}\n'})}),"\n",(0,a.jsxs)(e.h4,{id:"getsyncprotocolname-optional",children:[(0,a.jsx)(e.code,{children:"getSyncProtocolName()"})," (Optional)"]}),"\n",(0,a.jsxs)(e.p,{children:["Return the Effectstream Sync protocol name for event filtering and ",(0,a.jsx)(e.code,{children:"wait-effectstream-processed"})," queries:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'getSyncProtocolName(): string {\n  return this.paimaSyncProtocolName;  // e.g., "mainEvmRPC"\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:["If not implemented, the batcher falls back to ",(0,a.jsx)(e.code,{children:"getChainName()"}),"."]}),"\n",(0,a.jsx)(e.h4,{id:"isready",children:(0,a.jsx)(e.code,{children:"isReady()"})}),"\n",(0,a.jsx)(e.p,{children:"Check if the adapter is initialized and ready to submit transactions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"isReady(): boolean {\n  return this.walletClient !== undefined && this.publicClient !== undefined;\n}\n"})}),"\n",(0,a.jsx)(e.h4,{id:"getblocknumber",children:(0,a.jsx)(e.code,{children:"getBlockNumber()"})}),"\n",(0,a.jsx)(e.p,{children:"Get the latest block number:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async getBlockNumber(): Promise<bigint> {\n  return await this.publicClient.getBlockNumber();\n}\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"helper-classes-for-batch-serialization",children:"Helper Classes for Batch Serialization"}),"\n",(0,a.jsxs)(e.p,{children:["The batcher provides two helper classes for common serialization patterns. These are ",(0,a.jsx)(e.strong,{children:"optional"}),"\u2014you can always implement custom logic in ",(0,a.jsx)(e.code,{children:"buildBatchData()"}),"."]}),"\n",(0,a.jsx)(e.h3,{id:"defaultbatchbuilderlogic",children:(0,a.jsx)(e.code,{children:"DefaultBatchBuilderLogic"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Create the standard Paima JSON batch format used by the PaimaL2 contract."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Output Format:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'["&B", [\n  [addressType, address, signature, input, timestamp],\n  [addressType, address, signature, input, timestamp],\n  ...\n]]\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Usage:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'import { DefaultBatchBuilderLogic } from "@effectstream/batcher";\n\nexport class MyEVMAdapter implements BlockchainAdapter<string> {\n  private readonly batchBuilderLogic = new DefaultBatchBuilderLogic();\n  \n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<string> | null {\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Implementation Details:"})}),"\n",(0,a.jsx)(e.p,{children:"The helper:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["Starts with ",(0,a.jsx)(e.code,{children:'maxSize - ["&B", []].length'})," bytes remaining"]}),"\n",(0,a.jsxs)(e.li,{children:["For each input:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Serializes it as ",(0,a.jsx)(e.code,{children:"[addressType, address, signature, input, timestamp]"})]}),"\n",(0,a.jsx)(e.li,{children:"Checks if it fits in remaining space"}),"\n",(0,a.jsx)(e.li,{children:"If yes, adds it to the batch; if no, stops"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["Returns ",(0,a.jsx)(e.code,{children:"{ selectedInputs, data: JSON.stringify(batch) }"})]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Source:"})," ",(0,a.jsx)(e.code,{children:"packages/batcher/batch-data-builder/default-builder-logic.ts"})]}),"\n",(0,a.jsx)(e.h3,{id:"midnightbatchbuilderlogic",children:(0,a.jsx)(e.code,{children:"MidnightBatchBuilderLogic"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose:"})," Create structured circuit invocation payloads for Midnight contracts."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Output Format:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'{\n  prefix: "&B",\n  payloads: [\n    {\n      circuit: "transferBatch",\n      args: [100n, "0xabc..."],\n      addressType: 0,\n      address: "0x742d35Cc...",\n      signature: "...",\n      timestamp: "1234567890"\n    }\n  ]\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Usage:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'import { MidnightBatchBuilderLogic, type MidnightBatchPayload } from "@effectstream/batcher";\n\nexport class MyMidnightAdapter implements BlockchainAdapter<MidnightBatchPayload | null> {\n  private readonly batchBuilderLogic = new MidnightBatchBuilderLogic();\n  \n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<MidnightBatchPayload | null> | null {\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Implementation Details:"})}),"\n",(0,a.jsx)(e.p,{children:"The helper:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["Decodes each ",(0,a.jsx)(e.code,{children:"input.input"})," field (may be hex-encoded)"]}),"\n",(0,a.jsxs)(e.li,{children:["Parses it as JSON: ",(0,a.jsx)(e.code,{children:"{ circuit: string, args: any[] }"})]}),"\n",(0,a.jsx)(e.li,{children:"Builds a structured payload with circuit invocation metadata"}),"\n",(0,a.jsxs)(e.li,{children:["Respects ",(0,a.jsx)(e.code,{children:"maxSize"})," by estimating JSON-serialized size"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Source:"})," ",(0,a.jsx)(e.code,{children:"packages/batcher/batch-data-builder/midnight-builder-logic.ts"})]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"complete-adapter-examples",children:"Complete Adapter Examples"}),"\n",(0,a.jsx)(e.h3,{id:"example-1-erc1155customadapter-using-helper",children:"Example 1: ERC1155CustomAdapter (Using Helper)"}),"\n",(0,a.jsxs)(e.p,{children:["This adapter uses ",(0,a.jsx)(e.code,{children:"DefaultBatchBuilderLogic"})," for serialization but implements custom submission logic to route inputs to different ERC1155 contract functions."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\u2705 Uses ",(0,a.jsx)(e.code,{children:"DefaultBatchBuilderLogic"})," for batch serialization"]}),"\n",(0,a.jsxs)(e.li,{children:["\u2705 Parses JSON function calls from inputs (",(0,a.jsx)(e.code,{children:'{"function": "mint", "args": [...]}'}),")"]}),"\n",(0,a.jsxs)(e.li,{children:["\u2705 Routes to different contract functions (",(0,a.jsx)(e.code,{children:"mint()"}),", ",(0,a.jsx)(e.code,{children:"transferToMidnight()"}),")"]}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Pre-validates function names and argument counts"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'import { DefaultBatchBuilderLogic } from "@effectstream/batcher";\nimport type { BlockchainAdapter, DefaultBatcherInput } from "@effectstream/batcher";\n\nexport class ERC1155CustomAdapter implements BlockchainAdapter<string | null> {\n  private readonly batchBuilderLogic = new DefaultBatchBuilderLogic();\n  \n  // Use helper for batch building\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: { maxSize?: number }\n  ): { selectedInputs: DefaultBatcherInput[]; data: string } | null {\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n  \n  // Custom validation for function calls\n  validateInput(input: DefaultBatcherInput) {\n    try {\n      const functionCall = this.parseFunctionCall(input.input);\n      \n      switch (functionCall.function) {\n        case "mint":\n          if (functionCall.args.length !== 2) {\n            return {\n              valid: false,\n              error: `mint() expects 2 arguments, got ${functionCall.args.length}`\n            };\n          }\n          break;\n          \n        case "transferToMidnight":\n          if (functionCall.args.length !== 3) {\n            return {\n              valid: false,\n              error: `transferToMidnight() expects 3 arguments, got ${functionCall.args.length}`\n            };\n          }\n          break;\n          \n        default:\n          return {\n            valid: false,\n            error: `Unsupported function: ${functionCall.function}`\n          };\n      }\n      \n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : "Unknown validation error"\n      };\n    }\n  }\n  \n  // Custom submission logic\n  async submitBatch(data: string, fee?: string | bigint) {\n    // Parse default batch format: ["&B", [input1, input2, ...]]\n    const batchArray = this.parseDefaultBatchFormat(data);\n    \n    // Extract first input\n    const firstInput = JSON.parse(batchArray.inputs[0] as string);\n    const inputData = firstInput[3]; // The \'input\' field\n    \n    // Parse function call\n    const functionCall = this.parseFunctionCall(inputData);\n    \n    // Route to appropriate function\n    let hash: string;\n    switch (functionCall.function) {\n      case "mint": {\n        const [to, amount] = functionCall.args;\n        hash = await this.walletClient.writeContract({\n          account: this.account,\n          address: this.erc1155Address,\n          abi: mct_erc1155.abi,\n          functionName: "mint",\n          args: [to as `0x${string}`, BigInt(amount)],\n        });\n        break;\n      }\n      \n      case "transferToMidnight": {\n        const [amount, targetAddress, txHash] = functionCall.args;\n        hash = await this.walletClient.writeContract({\n          account: this.account,\n          address: this.erc1155Address,\n          abi: mct_erc1155.abi,\n          functionName: "transferToMidnight",\n          args: [BigInt(amount), targetAddress as `0x${string}`, txHash as `0x${string}`],\n        });\n        break;\n      }\n      \n      default:\n        throw new Error(`Unsupported function: ${functionCall.function}`);\n    }\n    \n    console.log(`\ud83d\ude80 Submitted transaction: ${hash}`);\n    return hash;\n  }\n  \n  // ... other required methods (waitForTransactionReceipt, etc.)\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Full Source:"})," ",(0,a.jsx)(e.code,{children:"templates/multi-chain-token-transfer/packages/client/batcher/erc1155-adapter.ts"})]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"example-2-midnightadapter-using-helper",children:"Example 2: MidnightAdapter (Using Helper)"}),"\n",(0,a.jsxs)(e.p,{children:["This adapter uses ",(0,a.jsx)(e.code,{children:"MidnightBatchBuilderLogic"})," for serialization and implements circuit invocation logic for the Midnight blockchain."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\u2705 Uses ",(0,a.jsx)(e.code,{children:"MidnightBatchBuilderLogic"})," for batch serialization"]}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Validates circuit arguments against contract schema"}),"\n",(0,a.jsxs)(e.li,{children:["\u2705 Bypasses signature verification (uses ",(0,a.jsx)(e.code,{children:"return true"}),")"]}),"\n",(0,a.jsxs)(e.li,{children:["\u2705 Invokes circuits via ",(0,a.jsx)(e.code,{children:"deployedContract.callTx[circuit](...args)"})]}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Queries Midnight indexer GraphQL API for transaction confirmation"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'import { MidnightBatchBuilderLogic, type MidnightBatchPayload } from "@effectstream/batcher";\nimport type { BlockchainAdapter, DefaultBatcherInput } from "@effectstream/batcher";\n\nexport class MidnightAdapter implements BlockchainAdapter<MidnightBatchPayload | null> {\n  private readonly batchBuilderLogic = new MidnightBatchBuilderLogic();\n  \n  // Bypass signature verification (Midnight uses circuit proofs)\n  verifySignature(input: DefaultBatcherInput): boolean {\n    return true;\n  }\n  \n  // Validate circuit arguments\n  validateInput(input: DefaultBatcherInput) {\n    try {\n      const decodedInput = this.decodeHexIfNeeded(input.input);\n      const parsed = JSON.parse(decodedInput);\n      \n      if (!parsed || typeof parsed.circuit !== "string" || !Array.isArray(parsed.args)) {\n        return {\n          valid: false,\n          error: "Invalid input structure. Expected { circuit: string, args: [] }"\n        };\n      }\n      \n      // Check circuit exists\n      const circuitDef = this.contractInfo.circuits.find(c => c.name === parsed.circuit);\n      if (!circuitDef) {\n        return {\n          valid: false,\n          error: `Circuit "${parsed.circuit}" not found`\n        };\n      }\n      \n      // Validate arguments\n      parseCircuitArgs(parsed.circuit, parsed.args, this.contractInfo);\n      \n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : "Unknown validation error"\n      };\n    }\n  }\n  \n  // Use helper for batch building\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<MidnightBatchPayload | null> | null {\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n  \n  // Submit via circuit invocation\n  async submitBatch(\n    data: MidnightBatchPayload | null,\n    fee?: string | bigint\n  ): Promise<BlockchainHash> {\n    if (!data || !data.payloads || data.payloads.length === 0) {\n      throw new Error("Batch payload contained no invocations");\n    }\n    \n    const { circuit, args } = data.payloads[0];\n    \n    // Check if circuit is pure (query) or impure (transaction)\n    const circuitDef = this.contractInfo.circuits.find(c => c.name === circuit);\n    if (!circuitDef) {\n      throw new Error(`Circuit "${circuit}" not found`);\n    }\n    \n    const parsedArgs = parseCircuitArgs(circuit, args, this.contractInfo);\n    \n    if (circuitDef.pure) {\n      // Pure circuit - local query, return fake hash\n      const result = await this.deployedContract.call[circuit](...parsedArgs);\n      return `query:${circuit}:${JSON.stringify(result)}`;\n    } else {\n      // Impure circuit - submit transaction\n      const result = await this.deployedContract.callTx[circuit](...parsedArgs);\n      \n      if (result?.public?.txHash) {\n        console.log(`\ud83d\ude80 Circuit invoked! Transaction Hash: ${result.public.txHash}`);\n        return result.public.txHash;\n      }\n      \n      throw new Error("Transaction result format unexpected");\n    }\n  }\n  \n  // Query Midnight indexer for confirmation\n  async waitForTransactionReceipt(\n    hash: BlockchainHash,\n    timeout: number = 60000\n  ): Promise<BlockchainTransactionReceipt> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      const txInfo = await this.queryTransactionStatus(hash);\n      \n      if (txInfo?.confirmed) {\n        return {\n          hash,\n          blockNumber: txInfo.blockNumber,\n          status: 1,\n        };\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    throw new Error(`Transaction confirmation timeout after ${timeout}ms`);\n  }\n  \n  private async queryTransactionStatus(txId: string) {\n    const query = `query ($hash: String!) {\n      transactions(offset: { hash: $hash }) {\n        applyStage\n        block { height }\n      }\n    }`;\n    \n    const response = await this.gqlQuery(query, { hash: txId });\n    \n    if (!response?.transactions?.[0]) return null;\n    \n    const tx = response.transactions[0];\n    return {\n      confirmed: tx.applyStage === "SucceedEntirely",\n      blockNumber: BigInt(tx.block.height),\n    };\n  }\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Full Source:"})," ",(0,a.jsx)(e.code,{children:"packages/batcher/adapters/midnight-adapter.ts"})]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Format Flexibility"}),": ",(0,a.jsx)(e.code,{children:"TOutput"})," can be any type\u2014string, object, binary. The only requirement is that ",(0,a.jsx)(e.code,{children:"submitBatch()"})," can parse what ",(0,a.jsx)(e.code,{children:"buildBatchData()"})," produces."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Helper Classes are Optional"}),": Use ",(0,a.jsx)(e.code,{children:"DefaultBatchBuilderLogic"})," or ",(0,a.jsx)(e.code,{children:"MidnightBatchBuilderLogic"})," for standard formats, or implement custom serialization for unique requirements."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Validation Happens Pre-Queue"}),": Implement ",(0,a.jsx)(e.code,{children:"validateInput()"})," to reject bad inputs ",(0,a.jsx)(e.strong,{children:"before"})," they hit storage. This prevents queue pollution."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Signature Verification is Overridable"}),": Return ",(0,a.jsx)(e.code,{children:"true"})," from ",(0,a.jsx)(e.code,{children:"verifySignature()"})," to bypass authentication if your chain uses alternative mechanisms (like circuit proofs)."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Each Method Maps to a Pipeline Step"}),": Understanding the ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline",children:"batching pipeline"})," helps you implement adapters correctly."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Type Safety Flows Through"}),": The generic ",(0,a.jsx)(e.code,{children:"TOutput"})," parameter ensures type safety from ",(0,a.jsx)(e.code,{children:"buildBatchData()"})," \u2192 ",(0,a.jsx)(e.code,{children:"estimateBatchFee()"})," \u2192 ",(0,a.jsx)(e.code,{children:"submitBatch()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Review ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/batching-pipeline",children:"The Batching Pipeline"})," to understand the complete flow"]}),"\n",(0,a.jsxs)(e.li,{children:["Explore ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/configuration",children:"Configuration"})," to learn how to wire adapters into the batcher"]}),"\n",(0,a.jsxs)(e.li,{children:["Check ",(0,a.jsx)(e.a,{href:"/docs/home/components/batcher/core-concepts",children:"Core Concepts"})," for deeper understanding of batcher architecture"]}),"\n",(0,a.jsxs)(e.li,{children:["Study the full adapter implementations:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"packages/batcher/adapters/paimal2-adapter.ts"})," (EVM reference)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"packages/batcher/adapters/midnight-adapter.ts"})," (Midnight reference)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"templates/multi-chain-token-transfer/packages/client/batcher/erc1155-adapter.ts"})," (Custom EVM example)"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);