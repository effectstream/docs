"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[7060],{5128:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"home/components/batcher/core-concepts","title":"Core Concepts","description":"Before diving into customization and advanced features, it\'s essential to understand the main components (\\"nouns\\") of the Batcher system. These building blocks work together to provide a flexible, multi-chain batching solution.","source":"@site/docs/home/100-components/108-batcher/1220-core-concepts.md","sourceDirName":"home/100-components/108-batcher","slug":"/home/components/batcher/core-concepts","permalink":"/docs/home/components/batcher/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/108-batcher/1220-core-concepts.md","tags":[],"version":"current","sidebarPosition":1220,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/home/components/batcher/introduction"},"next":{"title":"The Batching Pipeline","permalink":"/docs/home/components/batcher/batching-pipeline"}}');var r=t(2531),a=t(6613);const s={},c="Core Concepts",o={},l=[{value:"PaimaBatcher",id:"paimabatcher",level:2},{value:"Target",id:"target",level:2},{value:"PaimaBatcherConfig",id:"paimabatcherconfig",level:2},{value:"Core Configuration Fields",id:"core-configuration-fields",level:3},{value:"Confirmation Level: Global Default for HTTP API",id:"confirmation-level-global-default-for-http-api",level:3},{value:"Example Configuration",id:"example-configuration",level:3},{value:"Understanding maxBatchSize: Two Different Concepts",id:"understanding-maxbatchsize-two-different-concepts",level:3},{value:"Default Values",id:"default-values",level:3},{value:"BlockchainAdapter",id:"blockchainadapter",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:3},{value:"Key Methods",id:"key-methods",level:3},{value:"Example: PaimaL2DefaultAdapter",id:"example-paimal2defaultadapter",level:3},{value:"Custom Adapter Example",id:"custom-adapter-example",level:3},{value:"DefaultBatcherInput",id:"defaultbatcherinput",level:2},{value:"Field Descriptions",id:"field-descriptions",level:3},{value:"Extensibility: The Power of Generics",id:"extensibility-the-power-of-generics",level:3},{value:"How It Works: Generic Type Flow",id:"how-it-works-generic-type-flow",level:3},{value:"How They Work Together",id:"how-they-work-together",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,r.jsx)(n.p,{children:'Before diving into customization and advanced features, it\'s essential to understand the main components ("nouns") of the Batcher system. These building blocks work together to provide a flexible, multi-chain batching solution.'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"paimabatcher",children:"PaimaBatcher"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"PaimaBatcher"})})," is the main service instance that orchestrates all batching operations. It's created using the ",(0,r.jsx)(n.code,{children:"createNewBatcher()"})," factory function and manages the entire lifecycle of input collection, batch processing, and blockchain submission."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Responsibilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Accepts user inputs via the ",(0,r.jsx)(n.code,{children:"batchInput()"})," method or HTTP API"]}),"\n",(0,r.jsx)(n.li,{children:"Stores inputs persistently using pluggable storage backends"}),"\n",(0,r.jsx)(n.li,{children:"Evaluates batching criteria to determine when to process batches"}),"\n",(0,r.jsx)(n.li,{children:"Coordinates with blockchain adapters to submit transactions"}),"\n",(0,r.jsx)(n.li,{children:"Emits state transition events for observability"}),"\n",(0,r.jsx)(n.li,{children:"Manages graceful shutdown and resource cleanup"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class PaimaBatcher<T extends DefaultBatcherInput = DefaultBatcherInput>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The generic type parameter ",(0,r.jsx)(n.code,{children:"T"})," allows you to extend ",(0,r.jsx)(n.code,{children:"DefaultBatcherInput"})," with custom fields for your specific use case."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { createNewBatcher, FileStorage } from "@effectstream/batcher";\n\nconst batcher = createNewBatcher(\n  {\n    pollingIntervalMs: 1000,\n    adapters: { ethereum: ethAdapter },\n    defaultTarget: "ethereum",\n  },\n  new FileStorage("./batcher-data")\n);\n\n// Add custom event listeners\nbatcher.addStateTransition("startup", ({ publicConfig }) => {\n  console.log(`\ud83d\ude80 Batcher started on port ${publicConfig.port}`);\n});\n\n// Run the batcher\nawait batcher.init();\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"See Also:"})," The batcher uses ",(0,r.jsx)(n.strong,{children:"Effection"})," for structured concurrency, enabling automatic resource cleanup and graceful cancellation."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"target",children:"Target"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"target"})," is a string identifier that represents a specific blockchain destination. Each target corresponds to exactly one blockchain adapter in your configuration."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Routes inputs to the correct blockchain adapter"}),"\n",(0,r.jsx)(n.li,{children:"Allows batching criteria to be configured per blockchain"}),"\n",(0,r.jsx)(n.li,{children:"Enables multi-chain batching in a single batcher instance"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Examples:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"ethereum"'})," - For EVM-based chains like Ethereum mainnet"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"polygon"'})," - For Polygon network"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"midnight"'})," - For privacy-focused Midnight network"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"paimaL2"'})," - For the default Paima L2 contract"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Usage in Input:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const input: DefaultBatcherInput = {\n  addressType: AddressType.EVM,\n  address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",\n  input: "myGameMove|x5y10",\n  signature: "0x...",\n  timestamp: "1234567890",\n  target: "ethereum", // Specifies the destination chain\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"target"})," is not specified in the input, the batcher uses the ",(0,r.jsx)(n.code,{children:"defaultTarget"})," from the configuration."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"paimabatcherconfig",children:"PaimaBatcherConfig"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"PaimaBatcherConfig"})})," is the configuration object that defines global batcher settings and per-adapter behavior. It's provided when creating a new batcher instance."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface PaimaBatcherConfig<\n  TInput extends DefaultBatcherInput = DefaultBatcherInput,\n  TAdapters extends Record<string, BlockchainAdapter<any>> = Record<string, BlockchainAdapter<any>>\n>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"core-configuration-fields",children:"Core Configuration Fields"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'{\n  // Required: How often to check batching criteria (in milliseconds)\n  pollingIntervalMs: number;\n\n  // Optional: Blockchain adapters keyed by target name\n  adapters?: TAdapters;\n\n  // Optional: Default adapter when input.target not specified\n  defaultTarget?: string;\n\n  // Optional: Per-adapter batching rules\n  batchingCriteria?: {\n    [targetName: string]: {\n      criteriaType: "time" | "size" | "value" | "hybrid" | "custom";\n      timeWindowMs?: number;        // For time/hybrid criteria\n      maxBatchSize?: number;        // For size/hybrid criteria (number of inputs)\n      targetValue?: number;         // For value criteria\n      valueAccumulatorFn?: (input: T) => number;  // For value criteria\n      isBatchReadyFn?: (inputs: T[], lastProcessTime: number) => boolean | Promise<boolean>;  // For custom criteria\n    };\n  };\n\n  // Optional: Default confirmation behavior for HTTP API requests\n  // Can be a global default OR per-adapter\n  confirmationLevel?: \n    | "no-wait" | "wait-receipt" | "wait-effectstream-processed"\n    | Record<string, "no-wait" | "wait-receipt" | "wait-effectstream-processed">;\n\n  // Optional: HTTP server settings\n  enableHttpServer?: boolean;\n  port?: number;\n\n  // Optional: Event system\n  enableEventSystem?: boolean;\n\n  // Optional: Signature namespace for verification\n  namespace?: string;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"confirmation-level-global-default-for-http-api",children:"Confirmation Level: Global Default for HTTP API"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"confirmationLevel"})," configuration defines the ",(0,r.jsx)(n.strong,{children:"default waiting behavior"})," when inputs are submitted via the HTTP API without an explicit confirmation level. It does ",(0,r.jsx)(n.strong,{children:"not"})," affect the internal batch processing\u2014it only controls what happens after an input is queued."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Three Levels:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:'"no-wait"'})})," - Returns immediately after input is queued"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:'"wait-receipt"'})})," - Waits for blockchain transaction confirmation (default)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:'"wait-effectstream-processed"'})})," - Waits until Paima Engine processes the batch"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Global vs Per-Adapter:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Option 1: Single global default for all adapters\nconfirmationLevel: "wait-receipt"\n\n// Option 2: Per-adapter defaults\nconfirmationLevel: {\n  ethereum: "wait-receipt",      // Fast finality\n  polygon: "wait-effectstream-processed", // Wait for full processing\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When is it used?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["HTTP API calls to ",(0,r.jsx)(n.code,{children:"/batch-input"})," that don't specify a ",(0,r.jsx)(n.code,{children:"confirmationLevel"})," field"]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"batchInput()"})," method's second parameter overrides this default"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example HTTP API Request:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Uses the global confirmationLevel default\ncurl -X POST http://localhost:3334/batch-input \\\n  -H "Content-Type: application/json" \\\n  -d \'{"data": {...}}\'\n\n# Explicitly overrides the default\ncurl -X POST http://localhost:3334/batch-input \\\n  -H "Content-Type: application/json" \\\n  -d \'{"data": {...}, "confirmationLevel": "no-wait"}\'\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const config: PaimaBatcherConfig = {\n  pollingIntervalMs: 1000,\n  \n  // Configure multiple adapters for multi-chain support\n  adapters: {\n    ethereum: new PaimaL2DefaultAdapter(\n      "0x...", // Contract address\n      "0x...", // Private key\n      0n,      // Fee\n      "eth-mainnet" // Sync protocol name\n    ),\n    polygon: new PaimaL2DefaultAdapter(\n      "0x...",\n      "0x...",\n      0n,\n      "polygon-mainnet"\n    ),\n  },\n  \n  defaultTarget: "ethereum",\n  \n  // Per-adapter batching criteria\n  batchingCriteria: {\n    ethereum: { // Sends batch every 5s\n      criteriaType: "time", \n      timeWindowMs: 5000 \n    },\n    polygon: { // Sends batch every 3s or whenever batch size reaches 50 items\n      criteriaType: "hybrid", \n      timeWindowMs: 3000, \n      maxBatchSize: 50  // This is NUMBER OF INPUTS (not bytes)\n    },\n  },\n  \n  confirmationLevel: "wait-receipt",\n  enableHttpServer: true,\n  port: 3334,\n  enableEventSystem: true,\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"understanding-maxbatchsize-two-different-concepts",children:"Understanding maxBatchSize: Two Different Concepts"}),"\n",(0,r.jsxs)(n.p,{children:["There are ",(0,r.jsxs)(n.strong,{children:["two different ",(0,r.jsx)(n.code,{children:"maxBatchSize"})," settings"]})," that serve different purposes:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Batching Criteria's ",(0,r.jsx)(n.code,{children:"maxBatchSize"})]})," (in config.batchingCriteria)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit"}),": Number of inputs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Triggers batch processing when input count reaches threshold"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": ",(0,r.jsx)(n.code,{children:"maxBatchSize: 50"}),' means "process batch when 50 inputs are queued"']}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Adapter's ",(0,r.jsx)(n.code,{children:"maxBatchSize"})]})," (in BlockchainAdapter)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit"}),": Bytes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Limits the serialized batch payload size during ",(0,r.jsx)(n.code,{children:"buildBatchData()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": ",(0,r.jsx)(n.code,{children:"maxBatchSize: 10000"}),' means "stop adding inputs to batch when it reaches 10KB"']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example showing both:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const ethereumAdapter = new PaimaL2DefaultAdapter(\n  "0x...",\n  "0x...",\n  0n,\n  "eth-mainnet",\n  chains.mainnet,\n  10000  // Adapter maxBatchSize: 10KB limit for serialized data\n);\n\nconst config: PaimaBatcherConfig = {\n  adapters: { ethereum: ethereumAdapter },\n  batchingCriteria: {\n    ethereum: {\n      criteriaType: "size",\n      maxBatchSize: 100  // Criteria maxBatchSize: trigger after 100 inputs\n    }\n  }\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What happens?"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Batcher queues inputs until it has ",(0,r.jsx)(n.strong,{children:"100 inputs"})," (criteria threshold)"]}),"\n",(0,r.jsxs)(n.li,{children:["When processing, ",(0,r.jsx)(n.code,{children:"buildBatchData()"})," serializes inputs until reaching ",(0,r.jsx)(n.strong,{children:"10KB"})," (adapter limit)"]}),"\n",(0,r.jsx)(n.li,{children:"If 100 inputs exceed 10KB, only a subset fits in the batch; remaining inputs stay queued"}),"\n",(0,r.jsx)(n.li,{children:"Next polling cycle will process the remaining inputs"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"default-values",children:"Default Values"}),"\n",(0,r.jsx)(n.p,{children:"The batcher applies sensible defaults for optional fields:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"port"}),": 3000"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"enableHttpServer"}),": true"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"enableEventSystem"}),": false"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"confirmationLevel"}),': "wait-receipt"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"namespace"}),': "paima_batcher"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pollingIntervalMs"}),": 1000"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"blockchainadapter",children:"BlockchainAdapter"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"BlockchainAdapter"})}),' is the primary interface for customization. It acts as a "driver" for a specific blockchain, abstracting away chain-specific differences and providing a unified interface for the batcher.']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface BlockchainAdapter<TOutput>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The generic type parameter ",(0,r.jsx)(n.code,{children:"TOutput"})," represents the type of data that ",(0,r.jsx)(n.code,{children:"buildBatchData()"})," produces. This could be a string, a byte array, or a custom structure depending on your chain's requirements."]}),"\n",(0,r.jsx)(n.h3,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pre-queue Validation"})," - Validate inputs before they're added to storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Signature Verification"})," - Verify cryptographic signatures (or opt-out for chains without signatures)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch Data Building"})," - Serialize multiple inputs into a single batch payload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Submission"})," - Submit the batch to the blockchain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Confirmation Tracking"})," - Wait for transaction confirmation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface BlockchainAdapter<TOutput> {\n  // Build batch data from inputs\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<TOutput> | null;\n\n  // Submit batch to blockchain\n  submitBatch(data: TOutput, fee: string | bigint): Promise<BlockchainHash>;\n\n  // Wait for transaction confirmation\n  waitForTransactionReceipt(\n    hash: BlockchainHash,\n    timeout?: number\n  ): Promise<BlockchainTransactionReceipt>;\n\n  // Estimate transaction fee\n  estimateBatchFee(data: TOutput): Promise<string | bigint> | string | bigint;\n\n  // Get adapter information\n  getAccountAddress(): string;\n  getChainName(): string;\n  getSyncProtocolName?(): string;\n  isReady(): boolean;\n  getBlockNumber(): Promise<bigint>;\n\n  // Optional: Custom signature verification\n  verifySignature?(input: DefaultBatcherInput): boolean | Promise<boolean>;\n\n  // Optional: Pre-queue input validation\n  validateInput?(input: DefaultBatcherInput): ValidationResult | Promise<ValidationResult>;\n\n  // Optional: Maximum batch payload size in bytes\n  // Used by buildBatchData() to limit the serialized batch size\n  // Note: This is different from batching criteria's maxBatchSize (which counts inputs)\n  maxBatchSize?: number;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-paimal2defaultadapter",children:"Example: PaimaL2DefaultAdapter"}),"\n",(0,r.jsxs)(n.p,{children:["The built-in ",(0,r.jsx)(n.code,{children:"PaimaL2DefaultAdapter"})," provides a complete EVM implementation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class PaimaL2DefaultAdapter implements BlockchainAdapter<string> {\n  constructor(\n    paimaL2Address: EvmAddress,\n    batcherPrivateKey: EvmPrivateKey,\n    paimaL2Fee: bigint,\n    paimaSyncProtocolName: string,\n    chain: Chain = chains.hardhat,\n    maxBatchSize: number = 10000\n  ) {\n    // ... initialization\n  }\n\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<string> | null {\n    // Uses DefaultBatchBuilderLogic to create JSON batch data\n    return this.batchBuilderLogic.buildBatchData(inputs, options);\n  }\n\n  async submitBatch(data: string, fee?: string | bigint): Promise<BlockchainHash> {\n    // Submits to PaimaL2 contract via viem\n    const hexData = encodeHexFromString(data);\n    const hash = await this.walletClient.writeContract({\n      address: this.paimaL2Address,\n      abi: this.paimaL2Abi,\n      functionName: "paimaSubmitGameInput",\n      args: [hexData],\n      value: actualFee,\n    });\n    return hash;\n  }\n\n  // ... other methods\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-adapter-example",children:"Custom Adapter Example"}),"\n",(0,r.jsx)(n.p,{children:"For a non-EVM chain like Midnight (which uses zero-knowledge proofs and doesn't have traditional signatures):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class MidnightAdapter implements BlockchainAdapter<MidnightBatchPayload> {\n  // Override signature verification to skip it\n  verifySignature(input: DefaultBatcherInput): boolean {\n    // Midnight uses circuit-based validation, not signatures\n    return true;\n  }\n\n  // Implement custom input validation\n  async validateInput(input: DefaultBatcherInput): Promise<ValidationResult> {\n    // Validate circuit arguments format\n    const args = this.parseCircuitArgs(input);\n    if (!args) {\n      return { valid: false, error: "Invalid circuit arguments" };\n    }\n    return { valid: true };\n  }\n\n  buildBatchData(\n    inputs: DefaultBatcherInput[],\n    options?: BatchBuildingOptions\n  ): BatchBuildingResult<MidnightBatchPayload> | null {\n    // Custom batch building for Midnight\n    // ...\n  }\n\n  async submitBatch(data: MidnightBatchPayload, fee: string | bigint): Promise<BlockchainHash> {\n    // Submit to Midnight network using their SDK\n    // ...\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Insight:"})," By implementing the ",(0,r.jsx)(n.code,{children:"BlockchainAdapter"})," interface, you can integrate any blockchain into the batcher system, regardless of its underlying technology."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"defaultbatcherinput",children:"DefaultBatcherInput"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"DefaultBatcherInput"})})," is the standard JSON object structure expected by the batcher's ",(0,r.jsx)(n.code,{children:"/batch-input"})," API and ",(0,r.jsx)(n.code,{children:"batchInput()"}),' method. It acts as a "common envelope" containing essential fields for batching.']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface DefaultBatcherInput {\n  addressType: AddressType;  // e.g., AddressType.EVM\n  address: string;            // User's wallet address\n  input: string;              // The actual game/application input\n  signature?: string;         // Optional cryptographic signature\n  timestamp: string;          // Timestamp for ordering and signature verification\n  target?: string;            // Optional destination chain\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"field-descriptions",children:"Field Descriptions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Field"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Required"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"addressType"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"AddressType"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"The type of address (EVM, Algorand, Cardano, etc.)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"address"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"The user's wallet address or identifier"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"input"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"The application-specific input data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"signature"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Cryptographic signature (required for chains with signature verification)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"timestamp"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Unix timestamp in milliseconds"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"target"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsxs)(n.td,{children:["Destination chain identifier (defaults to ",(0,r.jsx)(n.code,{children:"defaultTarget"}),")"]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"extensibility-the-power-of-generics",children:"Extensibility: The Power of Generics"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["The ",(0,r.jsx)(n.code,{children:"DefaultBatcherInput"})," type is designed to be extended with custom fields."]})," This is crucial for supporting chain-specific or application-specific data."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Extending for Midnight Circuit Arguments"})}),"\n",(0,r.jsx)(n.p,{children:"Midnight requires circuit arguments instead of signatures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface MidnightBatcherInput extends DefaultBatcherInput {\n  circuitArgs?: string;  // JSON-encoded circuit arguments\n  proof?: string;        // Zero-knowledge proof data\n}\n\n// Create a batcher with custom input type\nconst batcher = new PaimaBatcher<MidnightBatcherInput>(\n  {\n    pollingIntervalMs: 1000,\n    adapters: { midnight: midnightAdapter },\n    defaultTarget: "midnight",\n  },\n  storage\n);\n\n// Now batchInput() accepts MidnightBatcherInput\nawait batcher.batchInput({\n  addressType: AddressType.EVM,\n  address: "0x...",\n  input: "myGameMove",\n  timestamp: Date.now().toString(),\n  circuitArgs: JSON.stringify({ /* ... */ }),  // Custom field!\n  proof: "0x...",                              // Custom field!\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Extending for Priority Fees"})}),"\n",(0,r.jsx)(n.p,{children:"Add priority levels for custom batching logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface PriorityBatcherInput extends DefaultBatcherInput {\n  priority: "low" | "medium" | "high";\n  maxFee?: bigint;\n}\n\nconst batcher = new PaimaBatcher<PriorityBatcherInput>(config, storage);\n\n// Custom batching criteria using the priority field\nconst criteria: BatchingCriteriaConfig<PriorityBatcherInput> = {\n  criteriaType: "custom",\n  isBatchReadyFn: (inputs) => {\n    // Process immediately if any high-priority input exists\n    return inputs.some(input => input.priority === "high");\n  },\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works-generic-type-flow",children:"How It Works: Generic Type Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 1. Define custom input type\ninterface MyCustomInput extends DefaultBatcherInput {\n  customField: string;\n}\n\n// 2. Pass generic to PaimaBatcher\nconst batcher = new PaimaBatcher<MyCustomInput>(config, storage);\n//                                ^^^^^^^^^^^^^\n\n// 3. Generic flows through the entire system:\n//    - batchInput() expects MyCustomInput\n//    - Storage operations use MyCustomInput\n//    - Adapter receives MyCustomInput[]\n//    - Batching criteria functions get MyCustomInput[]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This design ensures ",(0,r.jsx)(n.strong,{children:"type safety"})," throughout the batching pipeline while maintaining ",(0,r.jsx)(n.strong,{children:"flexibility"})," for diverse blockchain requirements."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"how-they-work-together",children:"How They Work Together"}),"\n",(0,r.jsxs)(n.p,{children:["Here's a complete flow showing how all core concepts interact, including ",(0,r.jsxs)(n.strong,{children:["extending ",(0,r.jsx)(n.code,{children:"DefaultBatcherInput"})]})," with custom fields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { \n  createNewBatcher, \n  PaimaBatcherConfig,\n  PaimaL2DefaultAdapter,\n  FileStorage,\n  DefaultBatcherInput,\n  AddressType \n} from "@effectstream/batcher";\n\n// 1. Define custom input type with additional fields\ninterface GameBatcherInput extends DefaultBatcherInput {\n  priority: "low" | "medium" | "high";  // Custom field for prioritization\n  gameSessionId?: string;                // Custom field for session tracking\n}\n\n// 2. Configure the PaimaBatcher with global settings\n// Note: Adapters can be added dynamically before initialization\nconst config: PaimaBatcherConfig = {\n  pollingIntervalMs: 1000,\n  // No adapters in config - we\'ll add them dynamically\n  port: 3334,\n};\n\n// 3. Create the PaimaBatcher instance with generic type parameter\n// This ensures type safety throughout the system\nconst batcher = createNewBatcher<GameBatcherInput>(config, new FileStorage("./data"));\n//                                ^^^^^^^^^^^^^^^^\n//                                Generic type flows through entire batcher!\n\n// 4. Create and add blockchain adapter dynamically\n// This must be done BEFORE init() or runBatcher()\nconst ethereumAdapter = new PaimaL2DefaultAdapter(\n  "0x1234...",  // PaimaL2 contract address\n  "0xabcd...",  // Batcher private key\n  0n,           // Transaction fee\n  "eth-mainnet" // Sync protocol name (target can differ from this)\n);\n\nbatcher.addBlockchainAdapter(\n  "ethereum",  // Target name\n  ethereumAdapter,\n  {\n    // Per-adapter batching criteria\n    criteriaType: "custom",\n    // Custom criteria can access the custom fields!\n    isBatchReadyFn: (inputs: GameBatcherInput[]) => {\n      // Process immediately if any high-priority input exists\n      return inputs.some(inp => inp.priority === "high") || inputs.length >= 10;\n    }\n  }\n);\n// \ud83c\udfaf "ethereum" is automatically set as defaultTarget (first adapter)\n\n// 5. Add event listeners for observability\nbatcher.addStateTransition("startup", ({ publicConfig }) => {\n  console.log(`Batcher ready. Default target: ${publicConfig.defaultTarget}`);\n});\n\n// 6. Initialize and run (adapters must be added before this!)\nawait batcher.init();\n\n// 7. Submit inputs using your custom GameBatcherInput type\n// TypeScript ensures all required fields are present (including custom ones!)\nconst input: GameBatcherInput = {\n  addressType: AddressType.EVM,\n  address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",\n  input: "gameMove|x10y20",\n  signature: "0x...",\n  timestamp: Date.now().toString(),\n  target: "ethereum",        // Routes to ethereumAdapter\n  priority: "high",          // Custom field!\n  gameSessionId: "session-123"  // Custom field!\n};\n\nconst receipt = await batcher.batchInput(input, "wait-receipt");\n//                   ^^^^^^^^^^^^^^^^^^\n//                   Expects GameBatcherInput, not DefaultBatcherInput!\n\nconsole.log(`Transaction confirmed in block ${receipt.blockNumber}`);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Takeaways from this Example:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generic Type Flows Through System"}),": ",(0,r.jsx)(n.code,{children:"createNewBatcher<GameBatcherInput>()"})," makes the entire batcher type-aware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety"}),": TypeScript enforces that all calls to ",(0,r.jsx)(n.code,{children:"batchInput()"})," include custom fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Criteria Access"}),": Batching criteria functions receive the extended type with custom fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Storage & Adapter Receive Extended Type"}),": The generic flows to storage operations and adapter methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero Runtime Overhead"}),": This is pure TypeScript\u2014no runtime checks or transformations needed"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"PaimaBatcher"})}),": The orchestrator managing the entire batching lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Target"})}),": String identifiers routing inputs to specific blockchains"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"PaimaBatcherConfig"})}),": Global configuration defining batcher behavior"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"BlockchainAdapter"})}),": Pluggable blockchain drivers implementing chain-specific logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"DefaultBatcherInput"})}),": Extensible input structure supporting custom fields via generics"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"With these core concepts in place, you're ready to explore customization, advanced batching strategies, and multi-chain architectures in the following sections."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(1491);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);