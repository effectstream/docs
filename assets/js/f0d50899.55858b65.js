"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[8290],{2117:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"home/components/frontend","title":"Frontend (dApp)","description":"The frontend is the user-facing part of your decentralized application, such as a web-based game or a user dashboard. Its primary role is to provide an interface for users to interact with your dApp\'s state.","source":"@site/docs/home/100-components/115-frontend.md","sourceDirName":"home/100-components","slug":"/home/components/frontend","permalink":"/docs/home/components/frontend","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/115-frontend.md","tags":[],"version":"current","sidebarPosition":115,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Achievements","permalink":"/docs/home/components/achievements"},"next":{"title":"Accounts","permalink":"/docs/home/components/accounts"}}');var i=t(2531),s=t(6613);const r={},o="Frontend (dApp)",c={},d=[{value:"Getting Started",id:"getting-started",level:2},{value:"Universal JavaScript Compatibility",id:"universal-javascript-compatibility",level:2},{value:"Standard Web Frameworks",id:"standard-web-frameworks",level:4},{value:"Game Engines",id:"game-engines",level:4},{value:"Writing Data to the Blockchain (Writes)",id:"writing-data-to-the-blockchain-writes",level:2},{value:"Connecting a Wallet",id:"connecting-a-wallet",level:3},{value:"Submission Methods",id:"submission-methods",level:3},{value:"Reading Data from the Effectstream (Reads)",id:"reading-data-from-the-effectstream-reads",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frontend-dapp",children:"Frontend (dApp)"})}),"\n",(0,i.jsx)(n.p,{children:"The frontend is the user-facing part of your decentralized application, such as a web-based game or a user dashboard. Its primary role is to provide an interface for users to interact with your dApp's state."}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"/templates/evm-midnight/"})," template includes a ",(0,i.jsx)(n.code,{children:"/packages/frontend/"})," folder containing a complete, working web application to serve as a starting point."]}),"\n",(0,i.jsx)(n.p,{children:"A frontend's interaction with Effectstream can be broken down into two main activities:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Writes"}),": Submitting new actions (transactions or signed messages) to the blockchain to change the application's state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reads"}),": Querying the Effectstream's API to fetch and display the current, aggregated state of the application."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"universal-javascript-compatibility",children:"Universal JavaScript Compatibility"}),"\n",(0,i.jsxs)(n.p,{children:["A core design principle of Effectstream's frontend libraries is that they are ",(0,i.jsx)(n.strong,{children:"framework-agnostic"}),". They are written in standard TypeScript and compile to JavaScript, meaning they are not tied to any specific UI framework like React or Vue."]}),"\n",(0,i.jsx)(n.p,{children:"This universality allows you to build your dApp with a wide range of tools."}),"\n",(0,i.jsx)(n.h4,{id:"standard-web-frameworks",children:"Standard Web Frameworks"}),"\n",(0,i.jsx)(n.p,{children:"You can seamlessly integrate Effectstream's frontend packages into any modern web framework:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"React & Next.js"}),"\n",(0,i.jsx)(n.li,{children:"Vue & Nuxt.js"}),"\n",(0,i.jsx)(n.li,{children:"Svelte & SvelteKit"}),"\n",(0,i.jsx)(n.li,{children:"And more..."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"game-engines",children:"Game Engines"}),"\n",(0,i.jsx)(n.p,{children:"This JavaScript-first approach is especially powerful for game developers. You can build your application using dedicated game engines and still connect to the Effectstream backend. If your engine can compile to a web target (WebGL/HTML5) and interface with browser JavaScript, it can be a Effectstream-powered game."}),"\n",(0,i.jsx)(n.p,{children:"Integration is possible with many popular game engines:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unity"}),": Use ",(0,i.jsx)(n.code,{children:"*.jslib"})," files to bridge C# game logic with Effectstream's JavaScript libraries."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GameMaker"}),": Use the native extension system to call JavaScript functions from GML."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Godot"}),": Use the ",(0,i.jsx)(n.code,{children:"JavaScriptBridge"})," singleton for seamless communication between GDScript and JavaScript."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phaser.js & PixiJS"}),": As native JavaScript frameworks, integration is direct and straightforward."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"writing-data-to-the-blockchain-writes",children:"Writing Data to the Blockchain (Writes)"}),"\n",(0,i.jsx)(n.p,{children:"To change the state of the application, the frontend must initiate a transaction or a signed message."}),"\n",(0,i.jsx)(n.h3,{id:"connecting-a-wallet",children:"Connecting a Wallet"}),"\n",(0,i.jsxs)(n.p,{children:["All write operations begin with connecting a user's wallet. The ",(0,i.jsx)(n.code,{children:"@effectstream/wallet"})," package provides a unified interface for connecting to various blockchain ecosystems."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { WalletMode, login } from '@effectstream/wallet';\n\n// Example for an injected EVM wallet like MetaMask\nconst loginInfo = await login(WalletMode.EvmInjected);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Supported wallet modes include ",(0,i.jsx)(n.code,{children:"EvmInjected"}),", ",(0,i.jsx)(n.code,{children:"Cardano"}),", ",(0,i.jsx)(n.code,{children:"Mina"}),", ",(0,i.jsx)(n.code,{children:"AvailJs"}),", and more, enabling truly cross-chain applications."]}),"\n",(0,i.jsx)(n.h3,{id:"submission-methods",children:"Submission Methods"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct Contract Interaction"}),": The standard Web3 approach where your frontend calls a function on a smart contract directly (e.g., minting an NFT)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct Effectstream L2 Contract Interaction"}),": A specific direct interaction where your frontend calls the ",(0,i.jsx)(n.code,{children:"submitInput"})," method on your game's ",(0,i.jsx)(n.code,{children:"PaimaL2Contract"})," with a grammar-formatted payload. The user pays the gas for this transaction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batcher Interaction"}),": The recommended approach for the best UX. The user signs a message, and the frontend sends it to a ",(0,i.jsx)(n.strong,{children:"Batcher"})," service via an HTTP request. The Batcher then submits the input on-chain, often covering the gas fee and allowing users from different chains to interact."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of a frontend submitting an input to the batcher:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { createMessageForBatcher } from \'@effectstream/concise\';\nimport { AddressType } from \'@effectstream/utils-backend\';\n\nconst appName = "";\nconst timestamp = Date.now();\nconst conciseInput = ["my-action", "0x1", "0x2"]; // Your grammar-formatted input\n\n\n// The user signs a message, not a transaction\nconst signature = await walletClient.signMessage({\n  message: createMessageForBatcher(\n    appName, timestamp, account.address, account.accountType, conciseInput\n  ),\n});\n\n// Send the signed payload to the Batcher via HTTP\nawait fetch(`${ENV.BATCHER_URL}/send-input`, {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify({ \n    data: {\n      userAddress: account.address,\n      addressType: account.accountType,\n      userSignature: signature,\n      conciseInput: conciseInput,\n      millisecondTimestamp: timestamp,\n    },\n    waitForConfirmation: "wait-effectstream-processed",\n  }),\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reading-data-from-the-effectstream-reads",children:"Reading Data from the Effectstream (Reads)"}),"\n",(0,i.jsx)(n.p,{children:"While you can read data directly from the blockchain, it is often slow, inefficient, and doesn't provide the rich, aggregated state of your Paima application."}),"\n",(0,i.jsxs)(n.p,{children:["The recommended way for a frontend to read data is by querying the powerful ",(0,i.jsx)(n.strong,{children:"API"})," exposed by the Effectstream Node. This API provides access to both built-in system data and your own custom application state."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/home/components/api",children:"Learn more about the Effectstream API"})})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(1491);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);