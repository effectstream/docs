"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[7276],{6613:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(1491);const s={},r=n.createContext(s);function a(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},8623:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"home/components/primitives","title":"Primitives","description":"Primitives are the fundamental building blocks of Effectstream\'s data-ingestion layer. They act as specialized, chain-aware listeners that connect the Sync Service to your State Machine.","source":"@site/docs/home/100-components/118-primitives.md","sourceDirName":"home/100-components","slug":"/home/components/primitives","permalink":"/docs/home/components/primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/118-primitives.md","tags":[],"version":"current","sidebarPosition":118,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Node Startup","permalink":"/docs/home/components/node-startup"},"next":{"title":"Supported Chains","permalink":"/docs/home/chains/"}}');var s=i(2531),r=i(6613);const a={},o="Primitives",c={},l=[{value:"Built-in Primitives",id:"built-in-primitives",level:2},{value:"How to Use",id:"how-to-use",level:3},{value:"Available Built-in Primitives",id:"available-built-in-primitives",level:3},{value:"Custom Primitives",id:"custom-primitives",level:2},{value:"How it Works",id:"how-it-works",level:3},{value:"1. Define the Class and Properties",id:"1-define-the-class-and-properties",level:4},{value:"2. Implement the <code>getPayload</code> Method",id:"2-implement-the-getpayload-method",level:4},{value:"3. Implement the <code>getConfig</code> Method",id:"3-implement-the-getconfig-method",level:4},{value:"4. Register the Custom Primitive",id:"4-register-the-custom-primitive",level:4}];function d(e){const t={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"primitives",children:"Primitives"})}),"\n",(0,s.jsxs)(t.p,{children:["Primitives are the fundamental building blocks of Effectstream's data-ingestion layer. They act as specialized, chain-aware listeners that connect the ",(0,s.jsx)(t.strong,{children:"Sync Service"})," to your ",(0,s.jsx)(t.strong,{children:"State Machine"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Each primitive is configured to monitor a specific on-chain address (like a smart contract) for a particular type of event or state change. When a matching event occurs, the primitive's job is to:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Parse"})," the raw on-chain data from the event."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Transform"})," it into a structured, type-safe JSON object."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Generate"})," an input that the Effectstream can schedule for execution by your State Machine."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This creates a deterministic and reliable pipeline from raw blockchain events to your dApp's business logic. Effectstream offers two types of primitives: built-in and custom."}),"\n",(0,s.jsx)(t.h2,{id:"built-in-primitives",children:"Built-in Primitives"}),"\n",(0,s.jsxs)(t.p,{children:["Effectstream provides a suite of pre-built primitives for the most common blockchain standards, such as ERC20, ERC721, and the ",(0,s.jsx)(t.code,{children:"PaimaL2Contract"}),". Using these is the quickest and easiest way to integrate standard on-chain assets and actions into your application."]}),"\n",(0,s.jsx)(t.h3,{id:"how-to-use",children:"How to Use"}),"\n",(0,s.jsxs)(t.p,{children:["You configure built-in primitives within your ",(0,s.jsx)(t.code,{children:"localhostConfig.ts"})," file using the ",(0,s.jsx)(t.code,{children:".buildPrimitives()"})," step of the ",(0,s.jsx)(t.code,{children:"ConfigBuilder"}),". You simply need to provide the primitive's type, the contract address to monitor, and the ",(0,s.jsx)(t.code,{children:"stateMachinePrefix"})," that will trigger the corresponding State Transition Function (STF)."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, here is how you would configure a primitive to track an ",(0,s.jsx)(t.code,{children:"ERC721"})," NFT contract:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'// In your localhostConfig.ts\nimport { PrimitiveTypeEVMERC721 } from "@effectstream/sm/builtin";\n\n// ... inside new ConfigBuilder() ...\n  .buildPrimitives(builder =>\n    builder.addPrimitive(\n        (syncProtocols) => syncProtocols.mainEvmRPC,\n        (network, deployments, syncProtocol) => ({\n          name: "My_ERC721_NFT",\n          type: PrimitiveTypeEVMERC721, // Use the built-in ERC721 primitive type\n          startBlockHeight: 0,\n          contractAddress: "0x...", // The address of your deployed ERC721 contract\n          stateMachinePrefix: \'transfer-assets\', // This will trigger the \'transfer-assets\' STF\n        })\n    )\n  )\n'})}),"\n",(0,s.jsxs)(t.p,{children:["A key advantage of built-in primitives is that many come with automatic database integration. For example, the ",(0,s.jsx)(t.code,{children:"PrimitiveTypeEVMERC721"})," primitive will automatically create and maintain a dynamic table in your database that tracks the current owner of every token ID, which you can then easily query from your API. Learn more in the ",(0,s.jsx)(t.a,{href:"/docs/home/components/database",children:"Database section"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"available-built-in-primitives",children:"Available Built-in Primitives"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Primitive Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Chain"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeEVMPaimaL2"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"EVM"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Listens for inputs submitted to a standard ",(0,s.jsx)(t.code,{children:"PaimaL2Contract"}),"."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeEVMERC20"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"EVM"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Tracks ",(0,s.jsx)(t.code,{children:"Transfer"})," events for an ERC20 token and maintains balance tables."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeEVMERC721"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"EVM"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Tracks ",(0,s.jsx)(t.code,{children:"Transfer"})," events for an ERC721 NFT and maintains ownership tables."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeEVMERC1155"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"EVM"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Tracks ",(0,s.jsx)(t.code,{children:"TransferSingle"})," and ",(0,s.jsx)(t.code,{children:"TransferBatch"})," events for an ERC1155 token."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeMidnightGeneric"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Midnight"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Monitors the public ",(0,s.jsx)(t.code,{children:"ledger"})," state of a Midnight ZK contract for changes."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PrimitiveTypeAvailGeneric"})})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Avail"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Listens for generic data blobs submitted to a specific application ID on the Avail DA layer."})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"custom-primitives",children:"Custom Primitives"}),"\n",(0,s.jsxs)(t.p,{children:["For dApps that interact with unique, non-standard smart contracts or require custom data processing logic, you can create a ",(0,s.jsx)(t.strong,{children:"custom primitive"}),". The ",(0,s.jsx)(t.code,{children:"multi-chain-token-swap"})," template uses a custom primitive (",(0,s.jsx)(t.code,{children:"MCTErc1155Primitive"}),") to listen for its specific ",(0,s.jsx)(t.code,{children:"TransferToMidnight"})," event."]}),"\n",(0,s.jsx)(t.h3,{id:"how-it-works",children:"How it Works"}),"\n",(0,s.jsxs)(t.p,{children:["A custom primitive is a class that extends the abstract ",(0,s.jsx)(t.code,{children:"PaimaPrimitive"})," class. It requires you to implement the logic for parsing the on-chain event and generating the appropriate payload for the state machine."]}),"\n",(0,s.jsxs)(t.p,{children:["Here's a breakdown of the key parts of the ",(0,s.jsx)(t.code,{children:"MCTErc1155Primitive"})," implementation:"]}),"\n",(0,s.jsx)(t.h4,{id:"1-define-the-class-and-properties",children:"1. Define the Class and Properties"}),"\n",(0,s.jsx)(t.p,{children:"The class defines its unique type, the ABI of the event it's listening for, and the grammar of its output."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["NOTE: It is important that each sync protocol has different requirements for the primitive.",(0,s.jsx)(t.br,{}),"\n","For example EVM requires the ABI and Event Signature."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'// In packages/shared/custom-primitive-mct-erc1155/erc1155-primitive.ts\nimport { mct_erc1155 } from "@multi-chain-transfer/evm-contracts";\nimport { mctErc1155Grammar } from "./erc1155-grammar.ts";\n\nconst PrimitiveTypeEVMMCTERC1155 = "EVM:MCT_ERC1155" as const;\n\nexport class MCTErc1155Primitive extends PaimaPrimitive<\n  ConfigSyncProtocolType.EVM_RPC_PARALLEL,\n  typeof mctErc1155Grammar\n> {\n  readonly internalTypeName = PrimitiveTypeEVMMCTERC1155;\n  readonly abi = getEvmEvent(mct_erc1155.abi, "TransferToMidnight(address,string,uint256,uint256,string)");\n  override grammar = mctErc1155Grammar;\n  readonly contractAddress: EvmAddress;\n\n  constructor(config: { /* ... */ }) {\n    super(config);\n    this.contractAddress = Value.Decode(TypeboxHelpers.Evm.Address, config.contractAddress);\n  }\n  // ...\n}\n'})}),"\n",(0,s.jsxs)(t.h4,{id:"2-implement-the-getpayload-method",children:["2. Implement the ",(0,s.jsx)(t.code,{children:"getPayload"})," Method"]}),"\n",(0,s.jsxs)(t.p,{children:["This method is the heart of the primitive. It receives the raw event data from the Sync Service and is responsible for transforming it into structured ",(0,s.jsx)(t.code,{children:"accountingPayload"})," (for storage) and ",(0,s.jsx)(t.code,{children:"stateMachinePayload"})," (for execution)."]}),"\n",(0,s.jsx)(t.p,{children:"This function is expected to return two different payloads:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"accountingPayload"}),": This is the payload that will be stored in the database, and might be used for further processing."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"stateMachinePayload"}),": This is the payload that will be processed by the state machine, and only should be generated if a state-machine prefix is provided."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"// In packages/shared/custom-primitive-mct-erc1155/erc1155-primitive.ts\noverride *getPayload(\n  _: PaimaBlockNumber,\n  primitiveTransactionData: FlattenSyncProtocolIOFor<ConfigSyncProtocolType.EVM_RPC_PARALLEL>,\n): StateUpdateStream<{ /* ... */ }> {\n  // 1. Destructure the raw event data\n  const { from, midnight_address, amount, token_id, tx_hash } = primitiveTransactionData.output.payload;\n\n  // 2. Parse and validate the data\n  const fromAddr = Value.Decode(TypeboxHelpers.Evm.Address, from.toLowerCase());\n  const amountParsed = Value.Decode(TypeboxHelpers.Uint256, amount);\n  // ...\n\n  // 3. Create the structured payload object\n  const accountingPayload: ParamToData<typeof mctErc1155Grammar> = {\n    midnight_address: midnight_address,\n    from: fromAddr,\n    amount: amountParsed,\n    token_id: tokenIdParsed,\n    tx_hash: tx_hash,\n  };\n\n  // 4. Generate the input for the State Machine, using the defined prefix\n  const stateMachinePayload = this.stateMachinePrefix\n    ? generateRawStmInput(this.grammar, this.stateMachinePrefix, accountingPayload)\n    : null;\n\n  // 5. Return the final structured data\n  return {\n    isBatched: false,\n    data: [{\n      accountingPayload,\n      stateMachinePayload,\n      // ... other metadata\n    }],\n  };\n}\n"})}),"\n",(0,s.jsxs)(t.h4,{id:"3-implement-the-getconfig-method",children:["3. Implement the ",(0,s.jsx)(t.code,{children:"getConfig"})," Method"]}),"\n",(0,s.jsx)(t.p,{children:"This method returns the configuration object that the Sync Service will use to monitor the blockchain for this primitive's specific event."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"// In packages/shared/custom-primitive-mct-erc1155/erc1155-primitive.ts\noverride getConfig(): ProtocolPrimitiveMap[ConfigSyncProtocolType.EVM_RPC_PARALLEL] {\n  return {\n    name: this.instanceName,\n    type: this.internalTypeName,\n    startBlockHeight: this.startBlockHeight,\n    contractAddress: this.contractAddress,\n    abi: this.abi,\n    scheduledPrefix: this.stateMachinePrefix,\n  } as const;\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"4-register-the-custom-primitive",children:"4. Register the Custom Primitive"}),"\n",(0,s.jsxs)(t.p,{children:["The final step is to register your custom primitive class in your ",(0,s.jsx)(t.code,{children:"main.ts"})," file. This tells the Effectstream how to instantiate your primitive when it sees its ",(0,s.jsx)(t.code,{children:"internalTypeName"})," in the configuration."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'// In packages/client/node/src/main.ts\nimport { MCTErc1155Primitive } from "@multi-chain-transfer/custom-primitive-mct-erc1155/erc1155-primitive";\n\nmain(function* () {\n  // ...\n  yield* withPaimaStaticConfig(localhostConfig, function* () {\n    yield* start({\n      // ...\n      userDefinedPrimitives: {\n        "EVM:MCT_ERC1155": MCTErc1155Primitive,\n      },\n    });\n  });\n  // ...\n});\n'})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);