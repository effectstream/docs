"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[137],{5096:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"home/components/batcher","title":"Batcher","description":"NOTE THIS IS A PREVIEW DOCUMENTATION. NYI.","source":"@site/docs/home/100-components/108-batcher.md","sourceDirName":"home/100-components","slug":"/home/components/batcher","permalink":"/paima-v-next-docs/home/components/batcher","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/108-batcher.md","tags":[],"version":"current","sidebarPosition":108,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Paima Explorer","permalink":"/paima-v-next-docs/home/components/explorer"},"next":{"title":"Database","permalink":"/paima-v-next-docs/home/components/database"}}');var s=t(2531),a=t(6613);const r={},o="Batcher",c={},h=[{value:"Why Use a Batcher?",id:"why-use-a-batcher",level:3},{value:"How It Works: The Batching Flow",id:"how-it-works-the-batching-flow",level:3},{value:"The On-Chain Batch Format (<code>&amp;B</code>)",id:"the-on-chain-batch-format-b",level:3},{value:"Engine-Side Signature Verification",id:"engine-side-signature-verification",level:3},{value:"The Default Batcher Implementation",id:"the-default-batcher-implementation",level:3},{value:"Running the Batcher in Development",id:"running-the-batcher-in-development",level:3},{value:"Customizing the Batcher for Production",id:"customizing-the-batcher-for-production",level:3},{value:"1. Funding the Batcher",id:"1-funding-the-batcher",level:4},{value:"2. Implementing Custom Logic",id:"2-implementing-custom-logic",level:4},{value:"Frontend Integration: Sending an Input to the Batcher",id:"frontend-integration-sending-an-input-to-the-batcher",level:3},{value:"1. Construct the Game Input",id:"1-construct-the-game-input",level:4},{value:"2. Create and Sign the Batcher Message",id:"2-create-and-sign-the-batcher-message",level:4},{value:"3. Submit to the Batcher Endpoint",id:"3-submit-to-the-batcher-endpoint",level:4},{value:"Security Considerations for Production",id:"security-considerations-for-production",level:3},{value:"When to Bypass the Batcher",id:"when-to-bypass-the-batcher",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"batcher",children:"Batcher"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"NOTE THIS IS A PREVIEW DOCUMENTATION. NYI."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The Batcher is a server-side application that acts as a powerful intermediary between your users and the blockchain. Its primary purpose is to solve several major user experience challenges in Web3: gas fees, transaction speed, and cross-chain friction."}),"\n",(0,s.jsxs)(n.p,{children:["Instead of requiring every user to submit an on-chain transaction for every action, the Batcher allows them to simply ",(0,s.jsx)(n.strong,{children:"sign a message"})," with their wallet. The Batcher then collects these signed messages, bundles them into a single payload, and submits that payload to the ",(0,s.jsx)(n.code,{children:"PaimaL2Contract"})," in a single, efficient on-chain transaction."]}),"\n",(0,s.jsx)(n.h3,{id:"why-use-a-batcher",children:"Why Use a Batcher?"}),"\n",(0,s.jsx)(n.p,{children:"Integrating a Batcher offers significant advantages for your dApp:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gas Abstraction"}),': The Batcher pays the gas fees for all submitted transactions, allowing you to offer a "gasless" experience to your users.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chain Abstraction"}),": Since users only need to sign a message, they can use a wallet from ",(0,s.jsx)(n.strong,{children:"any supported chain"})," (like Cardano or Mina) to interact with your dApp, even if it's deployed on an EVM chain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Improved User Experience"}),": Users are not constantly interrupted by wallet pop-ups to approve transactions, leading to a much smoother experience."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Increased Throughput"}),": Bundling many actions into a single transaction significantly increases the number of user inputs processed per block."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works-the-batching-flow",children:"How It Works: The Batching Flow"}),"\n",(0,s.jsxs)(n.p,{children:["The process from user action to state change is a secure, multi-step flow where signature verification happens ",(0,s.jsx)(n.strong,{children:"inside the Paima Engine"}),", not on-chain."]}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User/Frontend\n    participant Batcher Service\n    participant EVM Blockchain (PaimaL2Contract)\n    participant Paima Engine\n\n    User/Frontend->>User/Frontend: User signs a message with their game input\n    User/Frontend->>+Batcher Service: POST /send-input with the signed payload\n    Batcher Service->>Batcher Service: Collects multiple signed inputs\n    Batcher Service->>+EVM Blockchain (PaimaL2Contract): Submits one transaction with a single, specially formatted `&B` string payload\n    EVM Blockchain (PaimaL2Contract)->>EVM Blockchain (PaimaL2Contract): Emits `PaimaGameInteraction` event\n    deactivate EVM Blockchain (PaimaL2Contract)\n    Paima Engine->>EVM Blockchain (PaimaL2Contract): Detects the event\n    Paima Engine->>Paima Engine: Parses the `&B` payload, and process each user input inside if valid\n    deactivate Batcher Service"}),"\n",(0,s.jsxs)(n.h3,{id:"the-on-chain-batch-format-b",children:["The On-Chain Batch Format (",(0,s.jsx)(n.code,{children:"&B"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["When the Batcher submits a transaction, it doesn't use a standard JSON array. Instead, it constructs a ",(0,s.jsx)(n.strong,{children:"single, specially formatted string"})," that starts with the built-in ",(0,s.jsx)(n.code,{children:"&B"}),' prefix. This string contains multiple "subunits," each representing a single user\'s signed input.']}),"\n",(0,s.jsxs)(n.p,{children:["The structure of the string payload is conceptually:\n",(0,s.jsx)(n.code,{children:"&B<subunit1><subunit2><subunit3>..."})]}),"\n",(0,s.jsx)(n.p,{children:"Each subunit contains all the information needed for the Paima Engine to verify and process an individual action:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The user's wallet address."}),"\n",(0,s.jsx)(n.li,{children:"The timestamp of the signature."}),"\n",(0,s.jsx)(n.li,{children:"The user's cryptographic signature."}),"\n",(0,s.jsxs)(n.li,{children:["The actual game input (as a stringified JSON array, e.g., ",(0,s.jsx)(n.code,{children:'"[\\"attack\\",1,42]"'}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"engine-side-signature-verification",children:"Engine-Side Signature Verification"}),"\n",(0,s.jsxs)(n.p,{children:["This is the most critical part of the Batcher's security model. The ",(0,s.jsx)(n.code,{children:"PaimaL2Contract"})," does not validate signatures; that would be incredibly gas-intensive. Instead, the Paima Engine performs this verification off-chain."]}),"\n",(0,s.jsxs)(n.p,{children:["When the engine's Sync Service detects a ",(0,s.jsx)(n.code,{children:"PaimaGameInteraction"})," event with a payload starting with ",(0,s.jsx)(n.code,{children:"&B"}),", it triggers a special process:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parse Batch"}),": The engine parses the single ",(0,s.jsx)(n.code,{children:"&B"})," string into its individual subunits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Iterate and Verify"}),": It loops through each subunit and performs the following steps:\na. ",(0,s.jsx)(n.strong,{children:"Reconstruct Message"}),": It uses the ",(0,s.jsx)(n.code,{children:"userAddress"}),", ",(0,s.jsx)(n.code,{children:"millisecondTimestamp"}),", and ",(0,s.jsx)(n.code,{children:"conciseInput"})," from the subunit to reconstruct the exact, deterministic message that the user's wallet was supposed to have signed.\nb. ",(0,s.jsx)(n.strong,{children:"Verify Signature"}),": It then attempts to verify the provided ",(0,s.jsx)(n.code,{children:"userSignature"})," against the reconstructed message. Crucially, it intelligently tries multiple signature schemes (EVM, Cardano, Mina, etc.) to determine the user's wallet type and validate accordingly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Process Valid Inputs"}),": If the signature is valid, the engine processes the ",(0,s.jsx)(n.code,{children:"conciseInput"})," through the standard Grammar and State Machine. If the signature is invalid, the subunit is safely discarded, and the engine moves to the next one. This prevents a single invalid signature from halting the entire batch."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-default-batcher-implementation",children:"The Default Batcher Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Paima Engine provides a robust, ready-to-use Batcher implementation out of the box. This default implementation handles all the core logic:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Running an HTTP server with a ",(0,s.jsx)(n.code,{children:"/send-input"})," endpoint."]}),"\n",(0,s.jsx)(n.li,{children:"Verifying cryptographic signatures for multiple wallet types."}),"\n",(0,s.jsx)(n.li,{children:"Storing pending inputs securely."}),"\n",(0,s.jsx)(n.li,{children:"Periodically bundling inputs into a valid on-chain batch."}),"\n",(0,s.jsxs)(n.li,{children:["Submitting the transaction to the ",(0,s.jsx)(n.code,{children:"PaimaL2Contract"})," and handling retries."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"running-the-batcher-in-development",children:"Running the Batcher in Development"}),"\n",(0,s.jsxs)(n.p,{children:["You can enable the default Batcher in your local development environment with a single flag in your orchestrator ",(0,s.jsx)(n.code,{children:"start.ts"})," file."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const config = Value.Parse(OrchestratorConfig, {\n  processes: {\n    // Set this flag to true to launch the default Batcher service.\n    [ComponentNames.PAIMA_BATCHER]: true,\n  },\n  // You must also provide the batcher configuration\n  batcher: {\n    paimaL2Address: "0x...",\n    batcherPrivateKey: "0x...", // A dev wallet private key\n    chainName: "hardhat",\n  },\n  // ...\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/paima-v-next-docs/home/components/processes",children:"Process Orchestrator"})," will automatically start and configure the Batcher service for you."]}),"\n",(0,s.jsx)(n.h3,{id:"customizing-the-batcher-for-production",children:"Customizing the Batcher for Production"}),"\n",(0,s.jsxs)(n.p,{children:["The default Batcher allows anyone to submit inputs. For a production environment, ",(0,s.jsx)(n.strong,{children:"you are responsible for deploying and customizing your own Batcher instance."})]}),"\n",(0,s.jsx)(n.p,{children:"This is a critical step, as it allows you to implement your dApp's specific business logic and monetization strategy."}),"\n",(0,s.jsx)(n.h4,{id:"1-funding-the-batcher",children:"1. Funding the Batcher"}),"\n",(0,s.jsx)(n.p,{children:"The Batcher's EVM wallet must be funded with the native currency of the target chain (e.g., ETH on Arbitrum) to pay for gas fees. You are responsible for keeping this wallet topped up."}),"\n",(0,s.jsx)(n.h4,{id:"2-implementing-custom-logic",children:"2. Implementing Custom Logic"}),"\n",(0,s.jsxs)(n.p,{children:["The most important reason to customize the Batcher is to add your own validation rules. Before verifying a signature and adding an input to the queue, your Batcher can (and should) query the ",(0,s.jsx)(n.strong,{children:"Paima Engine's API"}),' to check if the user is authorized to submit a "free" transaction.']}),"\n",(0,s.jsx)(n.p,{children:"This allows you to implement rules such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Allowing 10 free moves per day for any user."}),"\n",(0,s.jsx)(n.li,{children:"Granting unlimited free moves to users who own a specific NFT."}),"\n",(0,s.jsx)(n.li,{children:"Allowing users who have paid a subscription fee to submit inputs."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Conceptual Example (in your custom batcher's ",(0,s.jsx)(n.code,{children:"/send-input"})," handler):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'async function handleSendInput(request) {\n  const userInput = request.body;\n\n  // Custom Logic: Query the Paima Engine API\n  const paimaApiUrl = `http://paima-engine:3333/api/check-nft-ownership/${userInput.userAddress}`;\n  const response = await fetch(paimaApiUrl);\n  const { isNftHolder } = await response.json();\n\n  if (isNftHolder) {\n    // User is authorized, proceed with signature verification and add to queue.\n    await defaultBatcherLogic.addUserInput(userInput);\n  } else {\n    // User is not authorized, reject the request.\n    reply.status(403).send({ error: "User is not an NFT holder." });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"frontend-integration-sending-an-input-to-the-batcher",children:"Frontend Integration: Sending an Input to the Batcher"}),"\n",(0,s.jsxs)(n.p,{children:["Your frontend application is responsible for creating the correctly formatted signed message and sending it to the Batcher's ",(0,s.jsx)(n.code,{children:"/send-input"})," endpoint. The ",(0,s.jsx)(n.code,{children:"@paima/concise"})," and ",(0,s.jsx)(n.code,{children:"@paima/wallet"})," packages provide the necessary tools for this."]}),"\n",(0,s.jsx)(n.p,{children:"The process involves three main steps:"}),"\n",(0,s.jsx)(n.h4,{id:"1-construct-the-game-input",children:"1. Construct the Game Input"}),"\n",(0,s.jsxs)(n.p,{children:["First, create the game move as a standard JavaScript array, following the rules defined in your ",(0,s.jsx)(n.a,{href:"/paima-v-next-docs/home/components/grammar",children:"Grammar"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// The user\'s intended action, as a structured array.\nconst conciseInput = ["attack", 1, 42];\n'})}),"\n",(0,s.jsx)(n.h4,{id:"2-create-and-sign-the-batcher-message",children:"2. Create and Sign the Batcher Message"}),"\n",(0,s.jsxs)(n.p,{children:["This is the most critical step. The user does not sign the ",(0,s.jsx)(n.code,{children:"conciseInput"})," directly. Instead, you must use the ",(0,s.jsx)(n.code,{children:"createMessageForBatcher"})," helper function. This function combines the game input with other essential data (a timestamp, the user's address, and a security namespace) into a single, deterministic string. This is the string the user's wallet will sign."]}),"\n",(0,s.jsx)(n.p,{children:"It is crucial to use this specific function because the Paima Engine uses the exact same function internally to reconstruct the message for signature verification. Any deviation will result in an invalid signature."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { createMessageForBatcher } from \'@paima/concise\';\n\nconst timestamp = Date.now();\nconst userAddress = wallet.getAddress(); // e.g., "0x123..."\n\n// Create the precise message string that will be signed.\nconst messageToSign = createMessageForBatcher(\n  "my-security-namespace", // A unique string for your dApp to prevent cross-game replay attacks.\n  timestamp,\n  userAddress,\n  JSON.stringify(conciseInput) // The game input must be stringified.\n);\n\n// Use the wallet client to sign the message.\nconst signature = await walletClient.signMessage({\n  message: messageToSign,\n});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"3-submit-to-the-batcher-endpoint",children:"3. Submit to the Batcher Endpoint"}),"\n",(0,s.jsxs)(n.p,{children:["Finally, send all the components to the Batcher's ",(0,s.jsx)(n.code,{children:"/send-input"})," endpoint in a POST request."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// The body of the POST request.\nconst payload = {\n  addressType: AddressType.EVM, // The type of wallet the user signed with.\n  userAddress: userAddress,\n  userSignature: signature,\n  conciseInput: JSON.stringify(conciseInput),\n  millisecondTimestamp: timestamp,\n};\n\n// Send the request to your Batcher\'s URL.\nawait fetch(`${ENV.BATCHER_URL}/send-input`, {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify(payload),\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"security-considerations-for-production",children:"Security Considerations for Production"}),"\n",(0,s.jsx)(n.p,{children:"When deploying a custom Batcher, you are running a critical piece of infrastructure. Securing it is paramount."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batcher Wallet Security"}),": The Batcher's private key controls a wallet that must be funded to pay for gas. Treat this like any production hot wallet. Use a secure key management system and never expose the private key directly in your code or environment variables in an insecure manner."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timestamp Validity Window"}),": To prevent ",(0,s.jsx)(n.strong,{children:"replay attacks"})," (where an attacker captures a valid signed message and resubmits it later), your Batcher should enforce a strict validity window for timestamps. It should reject any incoming request where ",(0,s.jsx)(n.code,{children:"millisecondTimestamp"})," is too old (e.g., more than 30 seconds in the past) or in the future. The Paima Engine also performs a similar check, but rejecting invalid inputs early at the Batcher saves resources."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DoS Protection and Rate Limiting"}),": Your Batcher's ",(0,s.jsx)(n.code,{children:"/send-input"})," endpoint is publicly exposed. You must protect it from denial-of-service (DoS) attacks and spam. Implement standard web security practices like:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate Limiting"}),": Limit the number of requests a single IP address can make per minute."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CAPTCHA"}),": For anonymous users, you can integrate a service like Google's reCAPTCHA."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API Keys"}),": If your Batcher is being used by other backend services, require an API key."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input Validation"}),": Before even checking a signature, your custom Batcher can perform basic validation on the ",(0,s.jsx)(n.code,{children:"conciseInput"})," string. For example, you can check if it's valid JSON and if its size is within a reasonable limit to reject obvious junk requests immediately."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-bypass-the-batcher",children:"When to Bypass the Batcher"}),"\n",(0,s.jsx)(n.p,{children:"While the Batcher is the recommended approach for most user actions, there may be specific, high-stakes operations where a direct on-chain transaction is more appropriate."}),"\n",(0,s.jsxs)(n.p,{children:["Consider a direct ",(0,s.jsx)(n.code,{children:"PaimaL2Contract"})," interaction for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-Value Actions"}),": For actions that involve significant value (e.g., finalizing a tournament prize, claiming a rare asset), the friction of a direct wallet confirmation can be a desirable security feature."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Need for Abstraction"}),": If your dApp only runs on a single, low-cost chain and your target users are already familiar with paying gas fees, a Batcher might be an unnecessary architectural component."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For most dApps, a hybrid approach works best: use the Batcher for frequent, low-stakes actions (the game loop) and direct transactions for infrequent, high-stakes administrative tasks."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(1491);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);