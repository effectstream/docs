"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[7848],{4214:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"home/components/batcher/configuration","title":"Configuration","description":"Overview","source":"@site/docs/home/100-components/108-batcher/1240-configuration.md","sourceDirName":"home/100-components/108-batcher","slug":"/home/components/batcher/configuration","permalink":"/docs/home/components/batcher/configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/108-batcher/1240-configuration.md","tags":[],"version":"current","sidebarPosition":1240,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"The Batching Pipeline","permalink":"/docs/home/components/batcher/batching-pipeline"},"next":{"title":"Custom Adapters","permalink":"/docs/home/components/batcher/adapter"}}');var r=t(2531),a=t(6613);const s={},c="Configuration",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Target Audience",id:"target-audience",level:2},{value:"Configuration Architecture",id:"configuration-architecture",level:2},{value:"1. Dynamic Configuration (Recommended)",id:"1-dynamic-configuration-recommended",level:3},{value:"2. Unified Configuration (Alternative)",id:"2-unified-configuration-alternative",level:3},{value:"Configuration Steps (Dynamic Approach)",id:"configuration-steps-dynamic-approach",level:2},{value:"Step 1: Create Base Configuration",id:"step-1-create-base-configuration",level:3},{value:"Global Settings Reference",id:"global-settings-reference",level:4},{value:"Step 2: Instantiate Blockchain Adapters",id:"step-2-instantiate-blockchain-adapters",level:3},{value:"Step 3: Instantiate Batcher and Add Adapters Dynamically",id:"step-3-instantiate-batcher-and-add-adapters-dynamically",level:3},{value:"The <code>createNewBatcher()</code> Factory Function",id:"the-createnewbatcher-factory-function",level:4},{value:"The <code>addBlockchainAdapter()</code> Method",id:"the-addblockchainadapter-method",level:4},{value:"Step 4: Set Default Target",id:"step-4-set-default-target",level:3},{value:"The <code>setDefaultTarget()</code> Method",id:"the-setdefaulttarget-method",level:4},{value:"How Target Routing Works",id:"how-target-routing-works",level:3},{value:"Batching Criteria in Dynamic Configuration",id:"batching-criteria-in-dynamic-configuration",level:3},{value:"Step 5: Initialize and Start the Batcher",id:"step-5-initialize-and-start-the-batcher",level:3},{value:"Complete Example (Dynamic Configuration)",id:"complete-example-dynamic-configuration",level:2},{value:"Alternative: Unified Configuration",id:"alternative-unified-configuration",level:2},{value:"Step 1: Define Complete Configuration",id:"step-1-define-complete-configuration",level:3},{value:"Step 2: Instantiate and Launch",id:"step-2-instantiate-and-launch",level:3},{value:"Confirmation Level Configuration",id:"confirmation-level-configuration",level:2},{value:"Storage Configuration",id:"storage-configuration",level:2},{value:"Graceful Shutdown Configuration",id:"graceful-shutdown-configuration",level:2},{value:"Shutdown Configuration",id:"shutdown-configuration",level:3},{value:"Shutdown Hooks",id:"shutdown-hooks",level:3},{value:"1. <code>preShutdown</code> Hook",id:"1-preshutdown-hook",level:4},{value:"2. <code>stopAcceptingInputs</code> Hook",id:"2-stopacceptinginputs-hook",level:4},{value:"3. <code>waitForProcessing</code> Hook",id:"3-waitforprocessing-hook",level:4},{value:"4. <code>cleanup</code> Hook",id:"4-cleanup-hook",level:4},{value:"5. <code>postShutdown</code> Hook",id:"5-postshutdown-hook",level:4},{value:"Shutdown Process Flow",id:"shutdown-process-flow",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Timeout Behavior",id:"timeout-behavior",level:3},{value:"Manual Shutdown",id:"manual-shutdown",level:3},{value:"Configuration Validation",id:"configuration-validation",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"configuration",children:"Configuration"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Configuring the Batcher involves creating a unified configuration object that defines global settings, blockchain adapters, and batching behavior. This guide walks through the complete configuration process\u2014from instantiating adapters to launching the batcher service."}),"\n",(0,r.jsx)(n.p,{children:"Understanding the configuration system helps you:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Wire multiple blockchain adapters to a single batcher"}),"\n",(0,r.jsx)(n.li,{children:"Configure different batching strategies per blockchain"}),"\n",(0,r.jsx)(n.li,{children:"Set appropriate confirmation levels for your use case"}),"\n",(0,r.jsx)(n.li,{children:"Customize HTTP server and event system behavior"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"target-audience",children:"Target Audience"}),"\n",(0,r.jsx)(n.p,{children:"Developers setting up the Batcher who need to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Connect to one or more blockchain networks"}),"\n",(0,r.jsx)(n.li,{children:"Configure batching behavior for different chains"}),"\n",(0,r.jsx)(n.li,{children:"Set up the HTTP server for receiving inputs"}),"\n",(0,r.jsx)(n.li,{children:"Customize confirmation levels and retry behavior"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuration-architecture",children:"Configuration Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The batcher supports two configuration approaches:"}),"\n",(0,r.jsx)(n.h3,{id:"1-dynamic-configuration-recommended",children:"1. Dynamic Configuration (Recommended)"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.strong,{children:"builder pattern"})," to wire adapters and criteria progressively after instantiation (before initialization):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// 1. Create batcher with base config (no adapters yet)\nconst batcher = createNewBatcher({\n  pollingIntervalMs: 1000,\n  port: 3334,\n  enableHttpServer: true,\n  adapters: {} // Start with no adapters\n}, storage);\n\n// 2. Dynamically add adapters with their criteria\nbatcher\n  .addBlockchainAdapter("evm", evmAdapter, { \n    criteriaType: "time", \n    timeWindowMs: 5000 \n  })\n  .addBlockchainAdapter("midnight", midnightAdapter, { \n    criteriaType: "size", \n    maxBatchSize: 10 \n  })\n  .setDefaultTarget("evm");\n\n// 3. Initialize and start\nawait batcher.init();\n'})}),"\n",(0,r.jsx)(n.p,{children:"This approach offers maximum flexibility\u2014adapters can be added progressively before initialization."}),"\n",(0,r.jsx)(n.h3,{id:"2-unified-configuration-alternative",children:"2. Unified Configuration (Alternative)"}),"\n",(0,r.jsx)(n.p,{children:"Define everything in a single configuration object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const config: PaimaBatcherConfig = {\n  pollingIntervalMs: 1000,\n  port: 3334,\n  enableHttpServer: true,\n  \n  // Define adapters upfront\n  adapters: {\n    evm: evmAdapter,\n    midnight: midnightAdapter\n  },\n  \n  defaultTarget: "evm",\n  \n  // Per-adapter batching criteria\n  batchingCriteria: {\n    evm: { criteriaType: "time", timeWindowMs: 5000 },\n    midnight: { criteriaType: "size", maxBatchSize: 10 }\n  },\n  \n  confirmationLevel: "wait-receipt"\n};\n\nconst batcher = createNewBatcher(config, storage);\nawait batcher.init();\n'})}),"\n",(0,r.jsx)(n.p,{children:"This approach is more concise for static configurations but less flexible."}),"\n",(0,r.jsx)(n.admonition,{title:"When to Use Each Approach",type:"tip",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic configuration"}),": When adapters are conditionally enabled or loaded from plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unified configuration"}),": When all adapters are known at startup and configuration is static"]}),"\n"]})}),"\n",(0,r.jsxs)(n.admonition,{title:"Configuration Must Be Done Before Initialization",type:"warning",children:[(0,r.jsxs)(n.p,{children:["All configuration methods (",(0,r.jsx)(n.code,{children:"addBlockchainAdapter"}),", ",(0,r.jsx)(n.code,{children:"setDefaultTarget"}),", ",(0,r.jsx)(n.code,{children:"setBatchingCriteria"}),") must be called ",(0,r.jsx)(n.strong,{children:"before"})," calling ",(0,r.jsx)(n.code,{children:"init()"})," or ",(0,r.jsx)(n.code,{children:"runBatcher()"}),". Once the batcher is initialized, the configuration is locked and cannot be modified."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const batcher = createNewBatcher({ /* ... */ }, storage);\n\n// \u2705 OK: Adding adapters before init()\nbatcher.addBlockchainAdapter("evm", evmAdapter, { /* ... */ });\n\nawait batcher.init();\n\n// \u274c ERROR: Cannot add adapters after init()\nbatcher.addBlockchainAdapter("midnight", midnightAdapter, { /* ... */ });\n// Throws: "Cannot add adapters after batcher has been initialized"\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"configuration-steps-dynamic-approach",children:"Configuration Steps (Dynamic Approach)"}),"\n",(0,r.jsx)(n.p,{children:"The dynamic configuration approach follows these steps:"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-create-base-configuration",children:"Step 1: Create Base Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Create the base configuration object with global settings. ",(0,r.jsx)(n.strong,{children:"Adapters are not included here"}),"\u2014they'll be added dynamically in Step 3:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { type PaimaBatcherConfig } from "@paimaexample/batcher";\n\nconst baseConfig: PaimaBatcherConfig = {\n  // Polling frequency (how often to check if batching criteria are met)\n  pollingIntervalMs: 1000,  // Check every 1 second\n  \n  // HTTP server configuration\n  port: 3334,\n  enableHttpServer: true,  // Enable REST API endpoints\n  \n  // Event system for monitoring\n  enableEventSystem: true,  // Enable state transition events\n  \n  // Signature verification namespace\n  namespace: "paima_batcher",  // Used for signature message construction\n  \n  // Start with empty adapters - we\'ll add them dynamically\n  adapters: {}\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"global-settings-reference",children:"Global Settings Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Setting"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"pollingIntervalMs"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"1000"})}),(0,r.jsx)(n.td,{children:"How often to check if batching criteria are met (milliseconds)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"port"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"3000"})}),(0,r.jsx)(n.td,{children:"HTTP server port"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"enableHttpServer"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:"Whether to start the HTTP REST API"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"enableEventSystem"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:"Whether to enable state transition events"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"namespace"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'"paima_batcher"'})}),(0,r.jsx)(n.td,{children:"Namespace for signature verification"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"maxRetries"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"3"})}),(0,r.jsx)(n.td,{children:"Maximum retry attempts for failed transactions"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"retryDelayMs"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"1000"})}),(0,r.jsx)(n.td,{children:"Delay between retry attempts (milliseconds)"})]})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Set ",(0,r.jsx)(n.code,{children:"pollingIntervalMs"})," to match your shortest batching time window. For example, if using ",(0,r.jsx)(n.code,{children:"timeWindowMs: 5000"}),", a ",(0,r.jsx)(n.code,{children:"pollingIntervalMs"})," of 1000 ensures responsive batch submission."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-instantiate-blockchain-adapters",children:"Step 2: Instantiate Blockchain Adapters"}),"\n",(0,r.jsx)(n.p,{children:"Instantiate each blockchain adapter you want to use:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { PaimaL2DefaultAdapter } from "@paimaexample/batcher";\n\nconst evmAdapter = new PaimaL2DefaultAdapter(\n  "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",\n  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",\n  0n,\n  "mainEvmRPC"\n);\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Adapter Details",type:"info",children:(0,r.jsxs)(n.p,{children:["For comprehensive information about adapters, their responsibilities, and examples for different blockchains, see ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/core-concepts#blockchainadapter",children:"Core Concepts - BlockchainAdapter"}),"."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-instantiate-batcher-and-add-adapters-dynamically",children:"Step 3: Instantiate Batcher and Add Adapters Dynamically"}),"\n",(0,r.jsxs)(n.p,{children:["Now create the batcher instance and use the ",(0,r.jsx)(n.strong,{children:"builder pattern"})," to wire adapters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { createNewBatcher, FileStorage } from "@paimaexample/batcher";\n\n// Create storage\nconst storage = new FileStorage("./batcher-data");\n\n// Create batcher using the factory function\nconst batcher = createNewBatcher(baseConfig, storage);\n\n// Wire adapters using addBlockchainAdapter()\nbatcher\n  .addBlockchainAdapter(\n    "evm",              // Target name\n    evmAdapter,         // Adapter instance\n    {                   // Batching criteria for this adapter\n      criteriaType: "time",\n      timeWindowMs: 5000\n    }\n  )\n  .addBlockchainAdapter(\n    "midnight",\n    midnightAdapter,\n    {\n      criteriaType: "size",\n      maxBatchSize: 10\n    }\n  )\n  .addBlockchainAdapter(\n    "nft",\n    nftAdapter,\n    {\n      criteriaType: "hybrid",\n      timeWindowMs: 10000,\n      maxBatchSize: 20\n    }\n  );\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"the-createnewbatcher-factory-function",children:["The ",(0,r.jsx)(n.code,{children:"createNewBatcher()"})," Factory Function"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"createNewBatcher<T>(\n  config: PaimaBatcherConfig<T>,\n  storage?: BatcherStorage<T>\n): PaimaBatcher<T>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This factory function is the ",(0,r.jsx)(n.strong,{children:"recommended way"})," to create a batcher instance. It provides a cleaner API than using the constructor directly."]}),"\n",(0,r.jsxs)(n.h4,{id:"the-addblockchainadapter-method",children:["The ",(0,r.jsx)(n.code,{children:"addBlockchainAdapter()"})," Method"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"addBlockchainAdapter(\n  name: string,                          // Target name for routing\n  adapter: BlockchainAdapter<any>,       // Adapter instance\n  criteria: BatchingCriteriaConfig       // When to submit batches\n): PaimaBatcher\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wires"})," a target name to its adapter logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Assigns"})," batching criteria for this specific adapter"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Returns"})," the batcher instance for method chaining"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Must be called before ",(0,r.jsx)(n.code,{children:"init()"})]})," - throws error if batcher is already initialized"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Method Chaining",type:"tip",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"addBlockchainAdapter()"})," returns ",(0,r.jsx)(n.code,{children:"this"}),", enabling fluent method chaining to add multiple adapters."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-set-default-target",children:"Step 4: Set Default Target"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"setDefaultTarget()"})," to specify which adapter handles inputs without an explicit ",(0,r.jsx)(n.code,{children:"target"})," field:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'batcher.setDefaultTarget("evm");\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now inputs without a ",(0,r.jsx)(n.code,{children:"target"})," field will automatically route to the ",(0,r.jsx)(n.code,{children:"evmAdapter"}),"."]}),"\n",(0,r.jsxs)(n.h4,{id:"the-setdefaulttarget-method",children:["The ",(0,r.jsx)(n.code,{children:"setDefaultTarget()"})," Method"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"setDefaultTarget(target: string): PaimaBatcher\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sets"})," the default adapter for inputs without ",(0,r.jsx)(n.code,{children:"target"})," field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validates"})," that the target exists in the adapters map"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Returns"})," the batcher instance for method chaining"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Must be called before ",(0,r.jsx)(n.code,{children:"init()"})]})," - throws error if batcher is already initialized"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Required Adapters First",type:"warning",children:(0,r.jsxs)(n.p,{children:["You must call ",(0,r.jsx)(n.code,{children:"addBlockchainAdapter()"})," for a target before calling ",(0,r.jsx)(n.code,{children:"setDefaultTarget()"})," with that target name. Otherwise, validation will fail."]})}),"\n",(0,r.jsx)(n.h3,{id:"how-target-routing-works",children:"How Target Routing Works"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"target name"})," (e.g., ",(0,r.jsx)(n.code,{children:'"evm"'}),", ",(0,r.jsx)(n.code,{children:'"midnight"'}),") is how inputs route to the correct adapter:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Example input specifying target\n{\n  address: "0x...",\n  addressType: 0,\n  input: "myCommand|arg1|arg2",\n  signature: "0x...",\n  timestamp: "1234567890",\n  target: "midnight"  // Routes to midnightAdapter\n}\n\n// Example input using default target\n{\n  address: "0x...",\n  addressType: 0,\n  input: "myCommand|arg1|arg2",\n  signature: "0x...",\n  timestamp: "1234567890"\n  // No target specified -> routes to evmAdapter (the defaultTarget)\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Target Names Must Match",type:"warning",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"target"})," field in inputs must exactly match a name passed to ",(0,r.jsx)(n.code,{children:"addBlockchainAdapter()"}),". Mismatched targets will result in a ",(0,r.jsx)(n.code,{children:"404"})," error."]})}),"\n",(0,r.jsx)(n.h3,{id:"batching-criteria-in-dynamic-configuration",children:"Batching Criteria in Dynamic Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Notice that batching criteria are specified ",(0,r.jsx)(n.strong,{children:"per-adapter"})," when calling ",(0,r.jsx)(n.code,{children:"addBlockchainAdapter()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'batcher.addBlockchainAdapter(\n  "evm",\n  evmAdapter,\n  { criteriaType: "time", timeWindowMs: 5000 }  // \u2190 Criteria here\n);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Each adapter gets its own independent batching rules. If no criteria is provided, it defaults to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'{ criteriaType: "size", maxBatchSize: 1 }  // Process immediately\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Batching Criteria Types",type:"info",children:(0,r.jsxs)(n.p,{children:["For detailed information about all batching criteria types (time, size, hybrid, value, custom) and their use cases, see ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/batching-pipeline#batching-criteria-types",children:"The Batching Pipeline - Batching Criteria Types"}),"."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-initialize-and-start-the-batcher",children:"Step 5: Initialize and Start the Batcher"}),"\n",(0,r.jsx)(n.p,{children:"With adapters wired and default target set, initialize and start the batcher:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'await batcher.init();\n\nconsole.log("\u2705 Batcher started successfully");\nconsole.log(`\ud83c\udf10 HTTP Server: http://localhost:${baseConfig.port}`);\n'})}),"\n",(0,r.jsx)(n.p,{children:"The batcher is now running and ready to accept inputs!"}),"\n",(0,r.jsx)(n.h2,{id:"complete-example-dynamic-configuration",children:"Complete Example (Dynamic Configuration)"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example using the dynamic approach:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import {\n  createNewBatcher,\n  FileStorage,\n  PaimaL2DefaultAdapter,\n  MidnightAdapter\n} from "@paimaexample/batcher";\n\n// 1. Instantiate adapters\nconst evmAdapter = new PaimaL2DefaultAdapter(\n  "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",\n  Deno.env.get("EVM_PRIVATE_KEY")!,\n  0n,\n  "mainEvmRPC"\n);\n\nconst midnightAdapter = new MidnightAdapter(\n  "0xabc...",\n  Deno.env.get("MIDNIGHT_WALLET_SEED")!,\n  {\n    indexer: "http://localhost:8088/api/v1/graphql",\n    indexerWS: "ws://localhost:8088/api/v1/graphql/ws",\n    node: "http://localhost:9944",\n    proofServer: "http://localhost:6300",\n    zkConfigPath: "./zkproof.json",\n    privateStateStoreName: "batcher-state",\n    privateStateId: "batcherPrivateState"\n  },\n  contractInstance,\n  witnesses,\n  contractInfo,\n  0,\n  "midnightRPC"\n);\n\n// 2. Create storage\nconst storage = new FileStorage("./batcher-data");\n\n// 3. Create batcher with base config\nconst batcher = createNewBatcher({\n  pollingIntervalMs: 1000,\n  port: 3334,\n  enableHttpServer: true,\n  enableEventSystem: true,\n  adapters: {} // Start empty\n}, storage);\n\n// 4. Wire adapters with their criteria\nbatcher\n  .addBlockchainAdapter("evm", evmAdapter, {\n    criteriaType: "time",\n    timeWindowMs: 5000\n  })\n  .addBlockchainAdapter("midnight", midnightAdapter, {\n    criteriaType: "hybrid",\n    timeWindowMs: 10000,\n    maxBatchSize: 20\n  })\n  .setDefaultTarget("evm");\n\n// 5. Initialize and start\nawait batcher.init();\n\nconsole.log("\ud83c\udfaf Batcher ready");\nconsole.log("\ud83d\udccb Adapters: evm (default), midnight");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"alternative-unified-configuration",children:"Alternative: Unified Configuration"}),"\n",(0,r.jsx)(n.p,{children:"If you prefer defining everything upfront, you can use the unified configuration approach:"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-define-complete-configuration",children:"Step 1: Define Complete Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import {\n  createNewBatcher,\n  FileStorage,\n  type PaimaBatcherConfig,\n  PaimaL2DefaultAdapter\n} from "@paimaexample/batcher";\n\n// Instantiate adapters first\nconst evmAdapter = new PaimaL2DefaultAdapter(/* ... */);\nconst midnightAdapter = new MidnightAdapter(/* ... */);\n\n// Create unified configuration\nconst config: PaimaBatcherConfig = {\n  pollingIntervalMs: 1000,\n  port: 3334,\n  enableHttpServer: true,\n  enableEventSystem: true,\n  \n  // Define all adapters upfront\n  adapters: {\n    evm: evmAdapter,\n    midnight: midnightAdapter\n  },\n  \n  // Set default target\n  defaultTarget: "evm",\n  \n  // Per-adapter batching criteria\n  batchingCriteria: {\n    evm: {\n      criteriaType: "time",\n      timeWindowMs: 5000\n    },\n    midnight: {\n      criteriaType: "hybrid",\n      timeWindowMs: 10000,\n      maxBatchSize: 20\n    }\n  }\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-instantiate-and-launch",children:"Step 2: Instantiate and Launch"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const storage = new FileStorage("./batcher-data");\nconst batcher = createNewBatcher(config, storage);\nawait batcher.init();\n'})}),"\n",(0,r.jsx)(n.p,{children:"This approach is more concise but offers less pre-initialization flexibility."}),"\n",(0,r.jsx)(n.h2,{id:"confirmation-level-configuration",children:"Confirmation Level Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Confirmation levels can be configured globally or per-adapter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Global: applies to all adapters\nconfirmationLevel: "wait-receipt"\n\n// Per-adapter: different levels for different chains\nconfirmationLevel: {\n  evm: "no-wait",\n  midnight: "wait-effectstream-processed"\n}\n'})}),"\n",(0,r.jsxs)(n.admonition,{title:"Understanding Confirmation Levels",type:"info",children:[(0,r.jsx)(n.p,{children:"For detailed information about confirmation levels, their behavior in the pipeline, and when to use each, see:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/core-concepts#confirmation-level-global-default-for-http-api",children:"Core Concepts - Confirmation Level"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/batching-pipeline#confirmation-level-fallback-logic",children:"The Batching Pipeline - Confirmation Levels"})}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"storage-configuration",children:"Storage Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Choose a storage backend for persisting pending inputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { FileStorage } from "@paimaexample/batcher";\n\nconst storage = new FileStorage("./batcher-data");\n'})}),"\n",(0,r.jsx)(n.p,{children:"Available storage options:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FileStorage"}),": Simple JSON file storage (good for development)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PostgreSQL"}),": Production-grade relational database (coming soon)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redis"}),": In-memory storage with persistence (coming soon)"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Storage is Critical",type:"warning",children:(0,r.jsx)(n.p,{children:"Storage is the single source of truth for all pending inputs. Choose a reliable storage backend for production use. The batcher survives crashes by reloading inputs from storage on restart."})}),"\n",(0,r.jsx)(n.h2,{id:"graceful-shutdown-configuration",children:"Graceful Shutdown Configuration"}),"\n",(0,r.jsx)(n.p,{children:"The batcher supports graceful shutdown with customizable hooks that execute at specific phases of the shutdown process."}),"\n",(0,r.jsx)(n.h3,{id:"shutdown-configuration",children:"Shutdown Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { createNewBatcher } from "@paimaexample/batcher";\n\nconst batcher = createNewBatcher({\n  pollingIntervalMs: 1000,\n  adapters: {},\n  shutdown: {\n    // Timeout for the entire shutdown process\n    timeoutMs: 30000,  // 30 seconds\n    \n    // Signal handling configuration\n    signalHandling: {\n      signals: ["SIGINT", "SIGTERM"],  // Which signals to listen for\n      exitCode: 0                       // Exit code after shutdown\n    },\n    \n    // Custom hooks for each shutdown phase\n    hooks: {\n      preShutdown: async (batcher) => {\n        console.log("\ud83d\uded1 Beginning graceful shutdown...");\n      },\n      stopAcceptingInputs: async (batcher) => {\n        console.log("\ud83d\udeab Stopped accepting new inputs");\n      },\n      waitForProcessing: async (batcher) => {\n        console.log("\u23f3 Waiting for batch processing to complete...");\n      },\n      cleanup: async (batcher) => {\n        console.log("\ud83e\uddf9 Cleaning up resources...");\n      },\n      postShutdown: async (batcher) => {\n        console.log("\u2705 Shutdown complete");\n      }\n    }\n  }\n}, storage);\n\nbatcher\n  .addBlockchainAdapter("evm", evmAdapter, { /* criteria */ })\n  .setDefaultTarget("evm");\n\nawait batcher.init();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"shutdown-hooks",children:"Shutdown Hooks"}),"\n",(0,r.jsxs)(n.p,{children:["The shutdown process executes in ",(0,r.jsx)(n.strong,{children:"5 distinct phases"}),", each with an optional hook you can customize:"]}),"\n",(0,r.jsxs)(n.h4,{id:"1-preshutdown-hook",children:["1. ",(0,r.jsx)(n.code,{children:"preShutdown"})," Hook"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executes:"})," At the very beginning of the shutdown process, before any shutdown logic runs."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"preShutdown?: (batcher: PaimaBatcher<T>) => Promise<void> | void\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Log shutdown initiation"}),"\n",(0,r.jsx)(n.li,{children:"Send notifications to monitoring systems"}),"\n",(0,r.jsx)(n.li,{children:'Set application state to "shutting down"'}),"\n",(0,r.jsx)(n.li,{children:"Begin draining external queues"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'preShutdown: async (batcher) => {\n  console.log("\ud83d\uded1 Shutdown initiated");\n  await notifyMonitoring({ event: "batcher_shutdown_start" });\n  await externalQueue.pauseProducers();\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"2-stopacceptinginputs-hook",children:["2. ",(0,r.jsx)(n.code,{children:"stopAcceptingInputs"})," Hook"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executes:"})," After HTTP server is stopped and polling has ended, but before waiting for ongoing processing."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"stopAcceptingInputs?: (batcher: PaimaBatcher<T>) => Promise<void> | void\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What Happens Before This Hook:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"HTTP server is stopped (no new API requests accepted)"}),"\n",(0,r.jsx)(n.li,{children:"Polling interval is cleared (no new batch processing triggered)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Close external connections"}),"\n",(0,r.jsx)(n.li,{children:"Stop consuming from external queues"}),"\n",(0,r.jsx)(n.li,{children:"Update load balancer health checks"}),"\n",(0,r.jsx)(n.li,{children:"Finalize any input-related state"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'stopAcceptingInputs: async (batcher) => {\n  console.log("\ud83d\udeab No longer accepting inputs");\n  await messageQueue.disconnect();\n  await redis.set("batcher:status", "draining");\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"3-waitforprocessing-hook",children:["3. ",(0,r.jsx)(n.code,{children:"waitForProcessing"})," Hook"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executes:"})," While waiting for any in-progress batch processing to complete."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"waitForProcessing?: (batcher: PaimaBatcher<T>) => Promise<void> | void\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What Happens Before This Hook:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The batcher waits for ",(0,r.jsx)(n.code,{children:"isProcessingBatch"})," to become false"]}),"\n",(0,r.jsxs)(n.li,{children:["This respects the ",(0,r.jsx)(n.code,{children:"timeoutMs"})," setting"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitor progress of ongoing operations"}),"\n",(0,r.jsx)(n.li,{children:"Log status updates during the wait"}),"\n",(0,r.jsx)(n.li,{children:"Perform parallel cleanup that can happen during processing"}),"\n",(0,r.jsx)(n.li,{children:"Update progress bars or status dashboards"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'waitForProcessing: async (batcher) => {\n  console.log("\u23f3 Waiting for ongoing batches to complete...");\n  const status = await batcher.getBatchingStatus();\n  console.log(`  Pending inputs: ${status.totalPendingInputs}`);\n  await metrics.gauge("batcher.shutdown.pending", status.totalPendingInputs);\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"4-cleanup-hook",children:["4. ",(0,r.jsx)(n.code,{children:"cleanup"})," Hook"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executes:"})," During the resource cleanup phase, after all processing has finished."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"cleanup?: (batcher: PaimaBatcher<T>) => Promise<void> | void\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What Happens Before This Hook:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All batch processing has completed"}),"\n",(0,r.jsxs)(n.li,{children:["Built-in ",(0,r.jsx)(n.code,{children:"cleanupResources()"})," is called"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Close database connections"}),"\n",(0,r.jsx)(n.li,{children:"Flush logs and metrics"}),"\n",(0,r.jsx)(n.li,{children:"Clean up temporary files"}),"\n",(0,r.jsx)(n.li,{children:"Release locks and semaphores"}),"\n",(0,r.jsx)(n.li,{children:"Disconnect from external services"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'cleanup: async (batcher) => {\n  console.log("\ud83e\uddf9 Cleaning up resources...");\n  await database.disconnect();\n  await logger.flush();\n  await redis.del("batcher:locks:*");\n  await fs.remove("./temp-batch-data");\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"5-postshutdown-hook",children:["5. ",(0,r.jsx)(n.code,{children:"postShutdown"})," Hook"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executes:"})," At the very end, after all shutdown logic has completed successfully."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"postShutdown?: (batcher: PaimaBatcher<T>) => Promise<void> | void\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Final logging"}),"\n",(0,r.jsx)(n.li,{children:"Send completion notifications"}),"\n",(0,r.jsx)(n.li,{children:"Record shutdown metrics"}),"\n",(0,r.jsx)(n.li,{children:'Update external state to "stopped"'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'postShutdown: async (batcher) => {\n  console.log("\u2705 Batcher shutdown complete");\n  await notifyMonitoring({ event: "batcher_shutdown_complete" });\n  await redis.set("batcher:status", "stopped");\n  await metrics.increment("batcher.shutdowns.successful");\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"shutdown-process-flow",children:"Shutdown Process Flow"}),"\n",(0,r.jsx)(n.p,{children:"The complete shutdown sequence:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. preShutdown hook\n   \u2193\n2. Stop HTTP server\n   Stop polling interval\n   \u2193\n3. stopAcceptingInputs hook\n   \u2193\n4. Wait for isProcessingBatch === false (respects timeoutMs)\n   \u2193\n5. waitForProcessing hook\n   \u2193\n6. Call built-in cleanupResources()\n   \u2193\n7. cleanup hook\n   \u2193\n8. postShutdown hook\n   \u2193\n9. Shutdown complete\n"})}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"If any hook throws an error:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": Shutdown process stops and error is thrown"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["With ",(0,r.jsx)(n.code,{children:"force: true"})]}),": Error is logged but shutdown continues"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Trigger shutdown with force option\nawait batcher.gracefulShutdown(hooks, { \n  timeoutMs: 30000,\n  force: true  // Continue shutdown even if hooks fail\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"timeout-behavior",children:"Timeout Behavior"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"timeoutMs"})," setting applies to the entire shutdown process:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"shutdown: {\n  timeoutMs: 30000  // 30 second timeout for complete shutdown\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"If the timeout is reached:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A warning is logged"}),"\n",(0,r.jsx)(n.li,{children:"Shutdown completes immediately"}),"\n",(0,r.jsx)(n.li,{children:"Any pending operations are interrupted"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"manual-shutdown",children:"Manual Shutdown"}),"\n",(0,r.jsx)(n.p,{children:"You can trigger shutdown manually (without signals):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Using the Effection operation (recommended)\nimport { main } from "effection";\n\nmain(function* () {\n  yield* batcher.runBatcher();\n  \n  // Later...\n  yield* batcher.gracefulShutdownOp(hooks, { timeoutMs: 30000 });\n});\n\n// Using the async version\nawait batcher.gracefulShutdown(hooks, { timeoutMs: 30000 });\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-validation",children:"Configuration Validation"}),"\n",(0,r.jsx)(n.p,{children:"The batcher validates configuration and provides helpful error messages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const batcher = createNewBatcher({ adapters: {} }, storage);\n\n// \u274c Invalid default target (adapter not added yet)\nbatcher.setDefaultTarget("evm");\n// Error: "evm" not in adapters - must call addBlockchainAdapter first\n\n// \u274c Missing required criteria fields\nbatcher.addBlockchainAdapter("evm", evmAdapter, {\n  criteriaType: "time"  // Error: timeWindowMs required for time criteria\n});\n\n// \u2705 Correct usage\nbatcher\n  .addBlockchainAdapter("evm", evmAdapter, {\n    criteriaType: "time",\n    timeWindowMs: 5000  // All required fields present\n  })\n  .setDefaultTarget("evm");  // Valid: "evm" exists now\n\n// \u274c Cannot modify after initialization\nawait batcher.init();\nbatcher.addBlockchainAdapter("midnight", midnightAdapter, { /* ... */ });\n// Error: "Cannot add adapters after batcher has been initialized"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Learn about ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/adapter",children:"Custom Adapters"})," to support new blockchains"]}),"\n",(0,r.jsxs)(n.li,{children:["Explore ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/advanced-topics#batching-criteria",children:"Batching Criteria"})," for advanced batch timing strategies"]}),"\n",(0,r.jsxs)(n.li,{children:["Review ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/batching-pipeline",children:"The Batching Pipeline"})," to understand the input lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:["Check ",(0,r.jsx)(n.a,{href:"/docs/home/components/batcher/advanced-topics#http-api",children:"HTTP API Reference"})," for endpoint documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},6613:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(1491);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);