"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[3419],{6613:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(1491);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},8271:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"home/components/randomness","title":"Randomness","description":"Randomness is essential for creating engaging and unpredictable games\u2014from dice rolls and loot drops to critical hit chances. However, in a deterministic system like Paima Engine, standard functions like Math.random() are strictly forbidden.","source":"@site/docs/home/100-components/113-randomness.md","sourceDirName":"home/100-components","slug":"/home/components/randomness","permalink":"/paima-v-next-docs/home/components/randomness","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-components/113-randomness.md","tags":[],"version":"current","sidebarPosition":113,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Wallets","permalink":"/paima-v-next-docs/home/components/wallets"},"next":{"title":"Achievements","permalink":"/paima-v-next-docs/home/components/achievements"}}');var o=s(2531),r=s(6613);const a={},i="Randomness",d={},c=[{value:"The Challenge: Deterministic Randomness",id:"the-challenge-deterministic-randomness",level:3},{value:"The Paima Randomness Model",id:"the-paima-randomness-model",level:3},{value:"Using Randomness in Your STF",id:"using-randomness-in-your-stf",level:3},{value:"Common Use Cases",id:"common-use-cases",level:4},{value:"How <code>Prando</code> Works: A Deeper Look",id:"how-prando-works-a-deeper-look",level:3}];function l(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"randomness",children:"Randomness"})}),"\n",(0,o.jsxs)(n.p,{children:["Randomness is essential for creating engaging and unpredictable games\u2014from dice rolls and loot drops to critical hit chances. However, in a deterministic system like Paima Engine, standard functions like ",(0,o.jsx)(n.code,{children:"Math.random()"})," are strictly forbidden."]}),"\n",(0,o.jsx)(n.h3,{id:"the-challenge-deterministic-randomness",children:"The Challenge: Deterministic Randomness"}),"\n",(0,o.jsxs)(n.p,{children:["A core requirement of any State Transition Function (STF) is that it must be ",(0,o.jsx)(n.strong,{children:"deterministic"}),". Given the same input, it must always produce the exact same output. Standard randomness functions are the opposite of this; they are designed to be unpredictable and will produce different results every time they are run."]}),"\n",(0,o.jsx)(n.p,{children:"If two different Paima nodes running your game's STF got different results from a random number generator, their states would diverge, breaking the consensus of the entire system."}),"\n",(0,o.jsx)(n.p,{children:"Paima Engine solves this by providing a secure, deterministic, and replayable source of randomness that is safe to use within your STFs."}),"\n",(0,o.jsx)(n.h3,{id:"the-paima-randomness-model",children:"The Paima Randomness Model"}),"\n",(0,o.jsx)(n.p,{children:"Paima's solution is built on two key components:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A Deterministic Block Seed"}),": For every block, the Paima Engine generates a unique, deterministic seed. This seed is derived from on-chain data from that block (such as the blocks hashes). Because this data is the same for every node, the resulting seed is also the same."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["The ",(0,o.jsx)(n.code,{children:"Prando"})," Class"]}),": This is a powerful ",(0,o.jsx)(n.strong,{children:"Pseudo-Random Number Generator (PRNG)"}),". A PRNG is an algorithm that takes a starting ",(0,o.jsx)(n.strong,{children:"seed"})," and produces a sequence of numbers that appear random, but are in fact completely predictable if you know the seed."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"using-randomness-in-your-stf",children:"Using Randomness in Your STF"}),"\n",(0,o.jsxs)(n.p,{children:["You do not need to create a ",(0,o.jsx)(n.code,{children:"Prando"})," instance yourself. The Paima Engine automatically initializes one for you using the current block's seed and provides it directly in the ",(0,o.jsx)(n.code,{children:"data"})," object of your STF."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// In your state-machine.ts\nstm.addStateTransition(\n  "attack",\n  function* (data) {\n    // The randomGenerator is ready to use.\n    const { randomGenerator } = data;\n\n    // Use it to generate deterministic random numbers.\n    const diceRoll = randomGenerator.nextInt(1, 6);\n\n    // ... your logic\n  },\n);\n'})}),"\n",(0,o.jsx)(n.h4,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"randomGenerator"})," object has several convenient methods for common game mechanics."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["Generating a Dice Roll (",(0,o.jsx)(n.code,{children:"nextInt"}),")"]}),"\nTo get a random integer within an inclusive range."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Returns a random integer between 1 and 6 (inclusive).\nconst diceRoll = randomGenerator.nextInt(1, 6);\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["Picking from a Loot Table (",(0,o.jsx)(n.code,{children:"nextArrayItem"}),")"]}),"\nTo randomly select an element from an array."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const lootTable = ['sword', 'shield', 'potion'];\nconst droppedItem = randomGenerator.nextArrayItem(lootTable);\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["Calculating a Probability (",(0,o.jsx)(n.code,{children:"next"}),")"]}),"\nTo check for a chance-based event, like a critical hit. The ",(0,o.jsx)(n.code,{children:"next()"})," method returns a float between 0 and 1."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const CRITICAL_HIT_CHANCE = 0.20; // 20% chance\n\nconst chance = randomGenerator.next(); // e.g., returns 0.153\nif (chance < CRITICAL_HIT_CHANCE) {\n  // It's a critical hit!\n}\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"how-prando-works-a-deeper-look",children:["How ",(0,o.jsx)(n.code,{children:"Prando"})," Works: A Deeper Look"]}),"\n",(0,o.jsxs)(n.p,{children:["It is crucial to understand that the ",(0,o.jsx)(n.code,{children:"Prando"})," class is ",(0,o.jsx)(n.strong,{children:"stateful"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Each time you call a method like ",(0,o.jsx)(n.code,{children:"nextInt()"}),", it performs two actions:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"It generates a number based on its current internal state."}),"\n",(0,o.jsxs)(n.li,{children:["It updates its internal state so the ",(0,o.jsx)(n.em,{children:"next"})," call will produce a different number."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["This means that the ",(0,o.jsx)(n.strong,{children:"order"})," in which you call randomness functions matters. The sequence of numbers is deterministic, but calling the same function twice in a row will not produce the same result."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Inside an STF...\nconst firstRoll = randomGenerator.nextInt(1, 6);  // Let's say this returns 4\nconst secondRoll = randomGenerator.nextInt(1, 6); // This will return the NEXT number in the sequence, e.g., 2.\n"})}),"\n",(0,o.jsx)(n.p,{children:"Because of this, you must ensure that your logic calls the randomness functions in the same order for all possible code paths to maintain determinism."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);