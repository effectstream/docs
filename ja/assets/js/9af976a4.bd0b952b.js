"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[2862],{1705:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/1204-ui-a0c760817b9cd1ea977cfcc928824268.png"},4311:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/1204-terminal-8084044829476ee4cb98c893a6e2e921.png"},6613:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(1491);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},7684:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"home/templates/multi-chain-swap","title":"Multi-Chain Token Swap","description":"-   Location: /templates/multi-chain-token-swap","source":"@site/docs/home/1200-templates/1204-multi-chain-swap.md","sourceDirName":"home/1200-templates","slug":"/home/templates/multi-chain-swap","permalink":"/docs/ja/home/templates/multi-chain-swap","draft":false,"unlisted":false,"editUrl":"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/1200-templates/1204-multi-chain-swap.md","tags":[],"version":"current","sidebarPosition":1204,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chess Template","permalink":"/docs/ja/home/templates/chess"}}');var a=t(2531),s=t(6613);const r={},c="Multi-Chain Token Swap",o={},d=[{value:"Core Concept: A Unified Multi-Chain Balance",id:"core-concept-a-unified-multi-chain-balance",level:2},{value:"Multi-Chain Token Swap in action",id:"multi-chain-token-swap-in-action",level:3},{value:"Launching the template from scratch",id:"launching-the-template-from-scratch",level:3},{value:"How to run this template",id:"how-to-run-this-template",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"The Components in Action",id:"the-components-in-action",level:2},{value:"1. On-Chain Contracts",id:"1-on-chain-contracts",level:3},{value:"Solidity Contract (<code>MCT_ERC1155.sol</code>)",id:"solidity-contract-mct_erc1155sol",level:4},{value:"Compact (Midnight) Contract (<code>multichain_multitoken.compact</code>)",id:"compact-midnight-contract-multichain_multitokencompact",level:4},{value:"2. Chain Configuration (<code>localhostConfig.ts</code>)",id:"2-chain-configuration-localhostconfigts",level:3},{value:"3. Monitor Contracts (<code>localhostConfig.ts</code>)",id:"3-monitor-contracts-localhostconfigts",level:3},{value:"4. State Machine (<code>state-machine.ts</code>)",id:"4-state-machine-state-machinets",level:3},{value:"5. Database Configuration (<code>database.sql</code>)",id:"5-database-configuration-databasesql",level:3},{value:"6. API Configuration (<code>api.ts</code>)",id:"6-api-configuration-apits",level:3},{value:"7. Faucet",id:"7-faucet",level:3},{value:"8. Grammar (<code>grammar.ts</code>)",id:"8-grammar-grammarts",level:3},{value:"9. DevOps and Startup (<code>start.ts</code>)",id:"9-devops-and-startup-startts",level:3},{value:"10. Engine Initialization (<code>main.ts</code>)",id:"10-engine-initialization-maints",level:3},{value:"11. Batcher Configuration",id:"11-batcher-configuration",level:3},{value:"Dual-Adapter Setup (<code>config.ts</code>)",id:"dual-adapter-setup-configts",level:4},{value:"Custom EVM Adapter (<code>erc1155-adapter.ts</code>)",id:"custom-evm-adapter-erc1155-adapterts",level:4},{value:"State Machine Integration (<code>calls.ts</code>)",id:"state-machine-integration-callsts",level:4},{value:"12. Custom Primitive: <code>MCTErc1155Primitive</code>",id:"12-custom-primitive-mcterc1155primitive",level:3},{value:"Event Listening (<code>erc1155-primitive.ts</code>)",id:"event-listening-erc1155-primitivets",level:4},{value:"Grammar (<code>erc1155-grammar.ts</code>)",id:"grammar-erc1155-grammarts",level:4},{value:"Payload Processing (<code>getPayload</code>)",id:"payload-processing-getpayload",level:4},{value:"Registration (<code>localhostConfig.ts</code>)",id:"registration-localhostconfigts",level:4},{value:"Project Folder Structure",id:"project-folder-structure",level:3}];function l(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"multi-chain-token-swap",children:"Multi-Chain Token Swap"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Location"}),": ",(0,a.jsx)(n.code,{children:"/templates/multi-chain-token-swap"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Highlights"}),": A dApp that showcases interoperability between EVM and Midnight, allowing users to swap ERC1155 tokens between the two chains."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"multi-chain-token-swap"})," template is a sophisticated example demonstrating how Effectstream can create a seamless multi-chain experience. It builds a dApp where a user's token balance is unified across an EVM chain and a Midnight ZK chain. When a user initiates a cross-chain transfer by triggering an event on one chain, the Effectstream detects this and uses a Batcher service to automatically mint a corresponding token on the other chain."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"UI",src:t(1705).A+"",width:"2584",height:"2150"})}),"\n",(0,a.jsx)(n.h2,{id:"core-concept-a-unified-multi-chain-balance",children:"Core Concept: A Unified Multi-Chain Balance"}),"\n",(0,a.jsx)(n.p,{children:"This template addresses a common challenge in Web3: asset fragmentation across different ecosystems. The goal is to create a system where users can interact with tokens on either EVM or Midnight, and the backend logic, powered by Effectstream, ensures the total supply and ownership remain consistent across both."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"EVM Chain"}),": Manages an ",(0,a.jsx)(n.code,{children:"ERC1155"})," token contract."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Midnight Chain"}),": Manages a ",(0,a.jsx)(n.code,{children:"MultiToken"})," ZK contract based on OpenZeppelin's EIP-1155 implementation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Effectstream"}),": Monitors both chains. When a ",(0,a.jsx)(n.code,{children:"transferTo<OtherChain>"})," event is detected, the State Machine instructs a Batcher to mint the token on the destination chain."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batcher"}),": An automated service that holds the authority to call the ",(0,a.jsx)(n.code,{children:"mint"})," functions on both contracts, executing the commands issued by the State Machine."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Frontend"}),": A unified interface for users to view their total balance and initiate cross-chain transfers. It reads balances from both the individual chains (for quick updates) and the Effectstream API (for the canonical, unified state)."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"multi-chain-token-swap-in-action",children:"Multi-Chain Token Swap in action"}),"\n",(0,a.jsx)("iframe",{src:"https://drive.google.com/file/d/1VLlwMyEECt1bpMjtlXG36L3ZqETuSJwv/preview",width:"640",height:"480",allow:"autoplay"}),"\n",(0,a.jsx)(n.h3,{id:"launching-the-template-from-scratch",children:"Launching the template from scratch"}),"\n",(0,a.jsx)("iframe",{src:"https://drive.google.com/file/d/1aUbQ41sbCeg-rjGfEJK2LFEiAFeAwRLY/preview",width:"640",height:"480",allow:"autoplay"}),"\n",(0,a.jsx)(n.h3,{id:"how-to-run-this-template",children:"How to run this template"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"# Clone the repository\ngit clone git@github.com:PaimaStudios/paima-engine.git --branch v-next effectstream-engine-demo\ncd effectstream-engine-demo/templates/multi-chain-token-transfer\n\n## Please install missing dependencies.\n## This will be automatically done in the future.\n./../check.sh\n\n# Install packages\ndeno install --allow-scripts && ./patch.sh\n\n# Compile contracts\ndeno task build:evm\ndeno task build:midnight\n\n# Launch Effectstream Node\ndeno task dev\n\n# You will need the Midnight Lace Wallet to interact with the dApp.\n# Wait until the Effectstream Node is Syncing Blocks\nopen http://localhost:10599\n# For EVM wallet you can use this Private Key:\n# 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6.\n# It has funds for testing in the local EVM chain.\n#\n# For Midnight you need to use the Faucet in the dApp to get funds.\n"})}),"\n",(0,a.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.p,{children:"The following diagram illustrates the complete flow of a cross-chain swap. It shows how the frontend can receive updates from two sources: a direct query to the destination chain for immediate feedback, and the Effectstream's API for the aggregated, canonical state."}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant User\n    participant Frontend dApp\n    participant EVM Chain (MCT_ERC1155)\n    participant Midnight Chain (Multitoken)\n    participant Effectstream Node\n    participant Batcher Service\n\n    User->>Frontend dApp: Clicks "Transfer to Midnight"\n    Frontend dApp->>EVM Chain (MCT_ERC1155): Calls `transferToMidnight(...)`\n    EVM Chain (MCT_ERC1155)--\x3e>Effectstream Node: Emits `TransferToMidnight` event\n\n    Effectstream Node->>Effectstream Node: [Sync Service] Detects event\n    Effectstream Node->>Effectstream Node: [State Machine] Processes STF\n    Effectstream Node->>Batcher Service: API call: `mintOnMidnight(...)`\n\n    Batcher Service->>Midnight Chain (Multitoken): Executes `mint(...)` circuit\n\n    Midnight Chain (Multitoken)--\x3e>Frontend dApp: dApp polls Midnight for direct balance confirmation\n    Frontend dApp->>User: UI updates based on both direct and unified data\n\n    Midnight Chain (Multitoken)--\x3e>Effectstream Node: Public ledger state changes\n\n    Effectstream Node->>Effectstream Node: [Sync Service] Detects new Midnight state'}),"\n",(0,a.jsx)(n.h2,{id:"the-components-in-action",children:"The Components in Action"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Terminal",src:t(4311).A+"",width:"1200",height:"677"})}),"\n",(0,a.jsx)(n.h3,{id:"1-on-chain-contracts",children:"1. On-Chain Contracts"}),"\n",(0,a.jsx)(n.p,{children:"The on-chain logic is split between two specialized contracts, one for each ecosystem."}),"\n",(0,a.jsxs)(n.h4,{id:"solidity-contract-mct_erc1155sol",children:["Solidity Contract (",(0,a.jsx)(n.code,{children:"MCT_ERC1155.sol"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["This is a standard OpenZeppelin ",(0,a.jsx)(n.code,{children:"ERC1155"})," contract with an added function, ",(0,a.jsx)(n.code,{children:"transferToMidnight"}),", which burns tokens on the EVM side and emits an event that the Effectstream can detect to initiate the mint on Midnight."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// In packages/shared/contracts/evm/src/contracts/ERC1155.sol\ncontract MCT_ERC1155 is ERC1155, Ownable {\n    // ... constructor and mint function ...\n\n    event TransferToMidnight(address indexed from, string midnight_address, uint256 amount, uint256 token_id, string tx_hash);\n\n    function transferToMidnight(uint256 _amount, string calldata _target_account, string calldata tx_hash) external {\n        address from = msg.sender;\n        _burn(from, TOKEN_ID, _amount);\n        emit TransferToMidnight(from, _target_account, _amount, TOKEN_ID, tx_hash);\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"compact-midnight-contract-multichain_multitokencompact",children:["Compact (Midnight) Contract (",(0,a.jsx)(n.code,{children:"multichain_multitoken.compact"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["This ZK contract, based on OpenZeppelin's ",(0,a.jsx)(n.code,{children:"MultiToken"})," library, manages the token on the Midnight network. The ",(0,a.jsx)(n.code,{children:"transferToEvm"})," circuit burns tokens and publicly discloses the transfer details on the ledger for Effectstream to process."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// In packages/shared/contracts/midnight/contract-eip-1155/src/multichain_multitoken.compact\nexport ledger actionName: Uint<128>;\nexport ledger actionTargetAddress: Opaque<'string'>;\nexport ledger actionValue: Uint<128>;\n\n// ... other circuits ...\n\nexport circuit transferToEvm(\n  target_address: Opaque<'string'>,\n  amount: Uint<128>,\n  txHash: Bytes<16>,\n): [] {\n  const caller = ownPublicKey();\n  const callerEither = left<ZswapCoinPublicKey, ContractAddress>(caller);\n  const callerTokenBalance = MultiToken_balanceOf(callerEither, 0);\n  assert(!txHashes.member(disclose(txHash)), \"Transaction already processed\");\n  assert(callerTokenBalance >= amount, \"Insufficient balance\");\n  burnFrom(callerEither, amount);\n  txHashes.insert(disclose(txHash));\n\n  actionName = 1007; // Corresponds to TRANSFER_TO_EVM action\n  actionTargetAddress = disclose(target_address);\n  actionValue = disclose(amount);\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"2-chain-configuration-localhostconfigts",children:["2. Chain Configuration (",(0,a.jsx)(n.code,{children:"localhostConfig.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The first step in any Effectstream project is defining the networks it will connect to. This is done in ",(0,a.jsx)(n.code,{children:"localhostConfig.ts"})," using the ",(0,a.jsx)(n.code,{children:"ConfigBuilder"}),". This template connects to a local Hardhat EVM node and a local Midnight node."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/data-types/src/localhostConfig.ts\nexport const localhostConfig = new ConfigBuilder()\n  // ...\n  .buildNetworks((builder) =>\n    builder\n      .addNetwork({\n        name: "ntp",\n        type: ConfigNetworkType.NTP,\n        // ... config for the main clock\n      })\n      .addViemNetwork({\n        ...hardhat,\n        name: "evmMain",\n      })\n      .addNetwork({\n        name: "midnight",\n        type: ConfigNetworkType.MIDNIGHT,\n        // ... midnight specific configuration\n      })\n  )\n  // ...\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"3-monitor-contracts-localhostconfigts",children:["3. Monitor Contracts (",(0,a.jsx)(n.code,{children:"localhostConfig.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Once the networks are defined, you must configure ",(0,a.jsx)(n.strong,{children:"Primitives"})," to tell the Sync Service what specific contracts and events to monitor. This template defines three key primitives:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/data-types/src/localhostConfig.ts\n.buildPrimitives((builder) =>\n    builder\n\n      // Primitive for standard ERC1155 transfers on EVM\n      // This keeps track of the standard ERC1155 transfers on the EVM chain\n      .addPrimitive(\n        (syncProtocols) => syncProtocols.mainEvmRPC,\n        (network, deployments, syncProtocol) => ({\n          name: "MULTI_CHAIN_TOKEN_EVM",\n          type: PrimitiveTypeEVMERC1155,\n          startBlockHeight: 0,\n          contractAddress: contractAddressesEvmMain()\n            .chain31337["Erc1155DevModule#MCT_ERC1155"],\n          stateMachinePrefix: "evm-transfer-erc1155",\n        })\n      )\n\n      // Custom primitive for the EVM -> Midnight transfer event\n      .addPrimitive(\n        (syncProtocols) => syncProtocols.mainEvmRPC,\n        (network, deployments, syncProtocol) => ({\n          name: "TRANSFER_TO_MIDNIGHT",\n          type: "EVM:MCT_ERC1155", // This is a user-defined custom primitive type\n          startBlockHeight: 0,\n          contractAddress: contractAddressesEvmMain()\n            .chain31337["Erc1155DevModule#MCT_ERC1155"],\n          stateMachinePrefix: "transfer-to-midnight",\n        })\n      )\n\n      // Generic primitive to watch the Midnight contract\'s public ledger\n      .addPrimitive(\n        (syncProtocols) => syncProtocols.parallelMidnight,\n        (network, deployments, syncProtocol) => ({\n          name: "MidnightContractState",\n          type: PrimitiveTypeMidnightGeneric,\n          startBlockHeight: 1,\n          contractAddress: readMidnightContract().contractAddress,\n          stateMachinePrefix: "midnightContractState",\n          contract: { ledger: MultiChainMultiTokenContract.ledger },\n          networkId: 0, // undeployed network id\n        })\n      )\n  )\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"4-state-machine-state-machinets",children:["4. State Machine (",(0,a.jsx)(n.code,{children:"state-machine.ts"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The State Machine contains the core off-chain logic that reacts to the on-chain events detected by the primitives. It orchestrates the cross-chain minting by calling the Batcher."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/node/src/state-machine.ts\nimport { mintInEvm, mintInMidnight } from "@multi-chain-transfer/batcher/calls";\n\n// Triggered by the `TRANSFER_TO_MIDNIGHT` primitive\nstm.addStateTransition("transfer-to-midnight", function* (data) {\n  const { midnight_address, amount } = data.parsedInput;\n  console.log("\ud83c\udf89 [TRANSFER-TO-MIDNIGHT] Transaction receipt:", data.parsedInput);\n  yield* mintInMidnight(midnight_address, BigInt(amount));\n});\n\n// Triggered by the `MidnightContractState` primitive\nstm.addStateTransition("midnightContractState", function* (data) {\n  const decodedData = data.parsedInput.payload;\n  const actionName = Number(decodedData.actionName);\n\n  if (actionName === MidnightContractActionName.TRANSFER_TO_EVM) {\n    console.log("\ud83c\udf89 [MIDNIGHT] Transfer to EVM action");\n    const targetAddress = data.parsedInput.payload.actionTargetAddress;\n    const value = decodedData.actionValue;\n    yield* mintInEvm(targetAddress, BigInt(value));\n  }\n});\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"5-database-configuration-databasesql",children:["5. Database Configuration (",(0,a.jsx)(n.code,{children:"database.sql"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["This template uses a single custom table, ",(0,a.jsx)(n.code,{children:"evm_midnight"}),", to store the aggregated token ownership data from both chains. This provides a unified data source for the API."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- In packages/client/database/src/migrations/database.sql\nCREATE TABLE evm_midnight (\n  id SERIAL PRIMARY KEY,\n  chain TEXT NOT NULL,\n  token_id TEXT NOT NULL,\n  amount numeric(78,0) NOT NULL,\n  contract_address TEXT NOT NULL,\n  owner TEXT NOT NULL,\n  block_height INTEGER NOT NULL\n);\n\nCREATE UNIQUE INDEX evm_midnight_contract_address_index ON evm_midnight(contract_address, token_id, owner);\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"6-api-configuration-apits",children:["6. API Configuration (",(0,a.jsx)(n.code,{children:"api.ts"}),")"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"API",src:t(8959).A+"",width:"2582",height:"536"})}),"\n",(0,a.jsxs)(n.p,{children:["A custom API endpoint is created to serve the unified token data to the frontend. Note that the endpoint ",(0,a.jsx)(n.code,{children:"/api/erc1155"})," actually serves ERC1155 data from the custom ",(0,a.jsx)(n.code,{children:"evm_midnight"})," table."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/node/src/api.ts\nexport const apiRouter: StartConfigApiRouter = async function (\n  server: fastify.FastifyInstance,\n  dbConn: Pool,\n): Promise<void> {\n  server.get("/api/erc1155", async (request, reply) => {\n    // ... checks if table exists ...\n    const result = await runPreparedQuery(\n      getEvmMidnight.run(undefined, dbConn),\n      "/api/erc1155",\n    );\n    reply.send(result);\n  });\n  \n  // A faucet endpoint for local development on Midnight\n  server.get("/api/faucet", async (request) => {\n    // ... logic to call a Deno task to fund a Midnight address ...\n  });\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"7-faucet",children:"7. Faucet"}),"\n",(0,a.jsx)(n.p,{children:"The faucet shows how we can add custom scripts & endpoints to the Effectstream Node."}),"\n",(0,a.jsx)(n.p,{children:"This faucet is added to allow transferring native funds to a Midnight Browser Wallet.\nTo this we added a Typescript script that does a transfer of 10 Dust to a given Midnight address."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/contracts/midnight/faucet.ts\n/* Transfer dust to lace wallet */\nconst transferRecipe = await wallet.transferTransaction([\n    {\n    amount: 10000000n, // 10 Dust\n    type: nativeToken(), // "tDUST",\n    receiverAddress,\n    },\n]);    \nconst provenTransaction = await wallet.proveTransaction(transferRecipe);\nconst submittedTransaction = await wallet.submitTransaction(provenTransaction);\nconsole.log("\u2705 Successfully transferred dust to receiver address ");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This script is then called from the endpoint ",(0,a.jsx)(n.code,{children:"/api/faucet"}),"."]}),"\n",(0,a.jsxs)(n.h3,{id:"8-grammar-grammarts",children:["8. Grammar (",(0,a.jsx)(n.code,{children:"grammar.ts"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The grammar defines the structure of the data that the State Machine will receive from the primitives, ensuring type-safety and proper parsing."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/data-types/src/grammar.ts\nexport const grammar = {\n  // Corresponds to the standard ERC1155 primitive\n  "evm-transfer-erc1155": builtinGrammars.evmErc1155,\n  \n  // Corresponds to the custom EVM->Midnight primitive\n  "transfer-to-midnight": mctErc1155Grammar,\n  \n  // Corresponds to the generic Midnight primitive\n  "midnightContractState": builtinGrammars.midnightGeneric,\n} as const satisfies GrammarDefinition;\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"9-devops-and-startup-startts",children:["9. DevOps and Startup (",(0,a.jsx)(n.code,{children:"start.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The Process Orchestrator is configured in ",(0,a.jsx)(n.code,{children:"/packages/client/node/scripts/start.ts"})," to launch the entire multi-chain development environment with a single command (",(0,a.jsx)(n.code,{children:"deno task dev"}),"). It uses helper functions like ",(0,a.jsx)(n.code,{children:"launchEvm"})," and ",(0,a.jsx)(n.code,{children:"launchMidnight"})," to manage the lifecycle of each blockchain, and also starts the Batcher and frontend services."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/node/scripts/start.ts\nconst config = Value.Parse(OrchestratorConfig, {\n// ... other configs ...\nprocessesToLaunch: [\n    launchEvm("@multi-chain-transfer/evm-contracts"),\n    midnightExtended("@multi-chain-transfer/midnight-contracts"),\n],\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"midnightExtended"})," function is a custom wrapper that not only launches the Midnight stack but also builds and serves the frontend, and starts the Batcher service."]}),"\n",(0,a.jsxs)(n.h3,{id:"10-engine-initialization-maints",children:["10. Engine Initialization (",(0,a.jsx)(n.code,{children:"main.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, the ",(0,a.jsx)(n.code,{children:"main.ts"})," file brings all the components together. It uses ",(0,a.jsx)(n.code,{children:"withPaimaStaticConfig"})," to load the ",(0,a.jsx)(n.code,{children:"localhostConfig"})," and then calls the ",(0,a.jsx)(n.code,{children:"start"})," function from ",(0,a.jsx)(n.code,{children:"@effectstream/runtime"}),", passing it the grammar, state transitions, API router, and other configurations to launch a fully operational Effectstream Node."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/node/src/main.ts\nimport { init, start } from "@effectstream/runtime";\nimport { main, suspend } from "effection";\nimport { localhostConfig } from "@multi-chain-transfer/data-types/localhostConfig";\n// ... other imports\n\nmain(function* () {\n  yield* init();\n  console.log("Starting Effectstream Node");\n\n  yield* withPaimaStaticConfig(localhostConfig, function* () {\n    yield* start({\n      appName: "multi-chain-token-transfer",\n      appVersion: "0.3.21",\n      syncInfo: toSyncProtocolWithNetwork(localhostConfig),\n      gameStateTransitions,\n      migrations: migrationTable,\n      apiRouter,\n      grammar,\n      userDefinedPrimitives: {\n        "EVM:MCT_ERC1155": MCTErc1155Primitive,\n      },\n    });\n  });\n\n  yield* suspend();\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"11-batcher-configuration",children:"11. Batcher Configuration"}),"\n",(0,a.jsx)(n.p,{children:"In this template, the Batcher acts as a trusted, automated service responsible for minting tokens on the destination chain after a transfer is initiated. It listens for API calls from the Effectstream's State Machine and executes the corresponding on-chain transactions."}),"\n",(0,a.jsxs)(n.h4,{id:"dual-adapter-setup-configts",children:["Dual-Adapter Setup (",(0,a.jsx)(n.code,{children:"config.ts"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The Batcher is configured to be multi-chain aware by using two distinct adapters: one for EVM and one for Midnight. This allows it to hold credentials and interact with both blockchain ecosystems."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"ERC1155CustomAdapter"})}),": A custom-built adapter specifically for the EVM ",(0,a.jsx)(n.code,{children:"MCT_ERC1155"})," contract."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"MidnightAdapter"})}),": A standard adapter for interacting with the Midnight network."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/batcher/config.ts\nexport const config: PaimaBatcherConfig = {\n  // ...\n  adapters: { \n    midnight: midnightAdapter,\n    evm: erc1155Adapter,\n  },\n  defaultTarget: "midnight",\n  batchingCriteria: {\n    midnight: { criteriaType: "size", maxBatchSize: 1 },\n    evm: { criteriaType: "size", maxBatchSize: 1 },\n  },\n  // ...\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"batchingCriteria"})," is set to ",(0,a.jsx)(n.code,{children:"size"})," with a ",(0,a.jsx)(n.code,{children:"maxBatchSize"})," of 1. This means the Batcher will process requests immediately as they come in, rather than waiting to bundle them. This is ideal for this template's automated, server-to-server communication flow."]}),"\n",(0,a.jsxs)(n.h4,{id:"custom-evm-adapter-erc1155-adapterts",children:["Custom EVM Adapter (",(0,a.jsx)(n.code,{children:"erc1155-adapter.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["A custom adapter is required because the Batcher isn't submitting generic inputs to a ",(0,a.jsx)(n.code,{children:"PaimaL2Contract"}),". Instead, it needs to call specific functions (",(0,a.jsx)(n.code,{children:"mint"})," or ",(0,a.jsx)(n.code,{children:"transferToMidnight"}),") on the ",(0,a.jsx)(n.code,{children:"MCT_ERC1155"})," contract. The custom adapter parses a JSON payload from the State Machine's request to determine which function to call and with what arguments."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/batcher/erc1155-adapter.ts\nexport class ERC1155CustomAdapter implements BlockchainAdapter {\n  // ...\n\n  async submitBatch(data: string, fee?: string | bigint) {\n    // ... logic to parse the batch ...\n    const firstInput = JSON.parse(batchArray.inputs[0]);\n    const inputData = firstInput[3]; // The \'input\' field contains the hex-encoded function call\n    \n    // Decode and parse the input to get the function call\n    const functionCall = this.parseFunctionCall(inputData);\n    \n    // Route to appropriate contract function\n    switch (functionCall.function) {\n      case "mint": {\n        const [to, amount] = functionCall.args;\n        hash = await this.walletClient.writeContract({\n          // ... call mint on the contract\n        });\n        break;\n      }\n      case "transferToMidnight": {\n        // ... call transferToMidnight on the contract\n        break;\n      }\n      default:\n        throw new Error(`Unsupported function: ${functionCall.function}`);\n    }\n    // ...\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"state-machine-integration-callsts",children:["State Machine Integration (",(0,a.jsx)(n.code,{children:"calls.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The State Machine triggers the Batcher through coroutine functions defined in ",(0,a.jsx)(n.code,{children:"calls.ts"}),". These functions construct the precise JSON payload that the custom EVM and Midnight adapters expect. This decouples the state machine's logic from the direct implementation details of the Batcher's transaction submission."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/client/batcher/calls.ts\n// Helper: Create the input payload for the ERC1155 mint function\nfunction createMintPayload(targetAddress: string, amount: bigint): string {\n  const payload = {\n    function: "mint",\n    args: [targetAddress, amount.toString()]\n  };\n  \n  const jsonString = JSON.stringify(payload);\n  const hexEncoded = "0x" + stringToHex(jsonString); // The custom adapter expects a hex-encoded string\n  \n  return hexEncoded;\n}\n\n// Coroutine operation called by the State Machine\nexport function* mintInEvm(target: string, value: bigint) {\n  // ... constructs the payload and creates a signed input ...\n  \n  const batcherInput = yield* World.promise(\n    createSignedInput(input, batcherTarget, timestamp)\n  );\n\n  // Sends the final payload to the batcher\'s /send-input endpoint\n  const response: Response = yield* World.promise(\n    fetch(BATCHER_ENDPOINT, {\n      method: "POST",\n      // ...\n      body: JSON.stringify({\n        data: batcherInput,\n        // We can wait for Batcher Confirmation, Chain Confirmation or Effectstream-Engine Confirmation.\n        confirmationLevel: "no-wait",\n      }),\n    })\n  );\n  // ...\n}\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"12-custom-primitive-mcterc1155primitive",children:["12. Custom Primitive: ",(0,a.jsx)(n.code,{children:"MCTErc1155Primitive"})]}),"\n",(0,a.jsxs)(n.p,{children:["To detect the cross-chain transfer initiation on the EVM side, a custom primitive named ",(0,a.jsx)(n.code,{children:"MCTErc1155Primitive"})," is defined.",(0,a.jsx)(n.br,{}),"\n","Its sole purpose is to listen for the specific ",(0,a.jsx)(n.code,{children:"TransferToMidnight"})," event and transform its data into a structured input for the State Machine."]}),"\n",(0,a.jsxs)(n.h4,{id:"event-listening-erc1155-primitivets",children:["Event Listening (",(0,a.jsx)(n.code,{children:"erc1155-primitive.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The primitive is configured to listen exclusively for the ",(0,a.jsx)(n.code,{children:"TransferToMidnight"})," event signature on the deployed ",(0,a.jsx)(n.code,{children:"MCT_ERC1155"})," contract."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/custom-primitive-mct-erc1155/erc1155-primitive.ts\nexport class MCTErc1155Primitive extends PaimaPrimitive<\n  ConfigSyncProtocolType.EVM_RPC_PARALLEL,\n  typeof mctErc1155Grammar\n> {\n  readonly internalTypeName = "EVM:MCT_ERC1155";\n  readonly abi = getEvmEvent(mct_erc1155.abi, "TransferToMidnight(address,string,uint256,uint256,string)");\n  override grammar = mctErc1155Grammar;\n  // ...\n}\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"grammar-erc1155-grammarts",children:["Grammar (",(0,a.jsx)(n.code,{children:"erc1155-grammar.ts"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The grammar defines the structure and types of the data that will be extracted from the event and passed to the State Machine."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/custom-primitive-mct-erc1155/erc1155-grammar.ts\nexport const mctErc1155Grammar = [\n    ["from", Type.String()],\n    ["midnight_address", Type.String()],\n    ["amount", Type.String()],\n    ["token_id", Type.String()],\n    ["tx_hash", Type.String()],\n] as const;\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"payload-processing-getpayload",children:["Payload Processing (",(0,a.jsx)(n.code,{children:"getPayload"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"getPayload"})," method is the core logic of the primitive. It receives the raw event data from the Sync Service, decodes it, and formats it into the ",(0,a.jsx)(n.code,{children:"accountingPayload"})," and the ",(0,a.jsx)(n.code,{children:"stateMachinePayload"})," that will be processed by the engine."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// In packages/shared/custom-primitive-mct-erc1155/erc1155-primitive.ts\noverride *getPayload(\n  // ...\n): StateUpdateStream<{ /* ... */ }> {\n  const { from, midnight_address, amount, token_id, tx_hash } = primitiveTransactionData.output.payload;\n\n  const accountingPayload: ParamToData<typeof mctErc1155Grammar> = {\n    midnight_address: midnight_address,\n    from: fromAddr,\n    amount: amountParsed,\n    token_id: tokenIdParsed,\n    tx_hash: tx_hash,\n  };\n\n  const stateMachinePayload = this.stateMachinePrefix\n    ? generateRawStmInput(\n        this.grammar,\n        this.stateMachinePrefix,\n        accountingPayload,\n      )\n    : null;\n\n  return {\n    isBatched: false,\n    data: [{\n      // ...\n      accountingPayload,\n      stateMachinePayload,\n    }],\n  };\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"registration-localhostconfigts",children:["Registration (",(0,a.jsx)(n.code,{children:"localhostConfig.ts"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, the custom primitive is registered in the main configuration file, where it is given the instance name ",(0,a.jsx)(n.code,{children:"TRANSFER_TO_MIDNIGHT"})," and linked to the ",(0,a.jsx)(n.code,{children:"transfer-to-midnight"})," STF prefix. This completes the data pipeline from on-chain event to state machine execution."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// In packages/shared/data-types/src/localhostConfig.ts\n.addPrimitive(\n  (syncProtocols) => syncProtocols.mainEvmRPC,\n  (network, deployments, syncProtocol) => ({\n    name: "TRANSFER_TO_MIDNIGHT",\n    type: "EVM:MCT_ERC1155",\n    // ...\n    stateMachinePrefix: "transfer-to-midnight",\n  })\n)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"project-folder-structure",children:"Project Folder Structure"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"multi-chain-token-swap"})," template is organized as a Deno workspace monorepo. This structure helps separate concerns, with distinct packages for the frontend, the Effectstream node, and shared code. Understanding this layout is key to navigating and modifying the template."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'/\n|-- deno.json                 # Deno workspace configuration and top-level tasks\n|-- README.md                 # Main project instructions\n|-- packages/\n|   |-- client/               # Contains the Effectstream Node implementation\n|   |   |-- database/         # Defines the SQL schema and typed queries\n|   |   |   `-- src/\n|   |   |       |-- migrations/database.sql # Custom table schema for token balances\n|   |   |       `-- sql/sm_example.sql      # SQL queries that become typed functions\n|   |   |\n|   |   |-- batcher/          # Configuration and custom logic for the Batcher service\n|   |   |   |-- config.ts     # Defines Batcher adapters (EVM, Midnight) and criteria\n|   |   |   |-- erc1155-adapter.ts # The custom adapter for the EVM contract\n|   |   |   `-- calls.ts      # Coroutines called by the State Machine to trigger the Batcher\n|   |   |\n|   |   `-- node/             # Core of the Effectstream Node\n|   |       `-- src/\n|   |           |-- main.ts          # Main entry point that starts the Effectstream\n|   |           |-- state-machine.ts # The core application logic (State Transition Functions)\n|   |           `-- api.ts           # Defines custom API endpoints (e.g., /api/erc721)\n|   |\n|   |-- frontend/             # The user-facing web application (React + Vite)\n|   |   |-- client/\n|   |   |   `-- src/\n|   |   |       |-- App.tsx     # Main React component and UI layout\n|   |   |       |--effectstream.ts    # Logic for connecting wallets (EVM, Midnight)\n|   |   |       `-- eip-1155-interact.ts # Logic for interacting with the Midnight contract\n|   |   `-- server/             # Simple Oak server to serve the built frontend\n|   |\n|   `-- shared/               # Code shared between the frontend and the backend node\n|       |-- contracts/        # Smart contract source code for both chains\n|       |   |-- evm/          # Solidity contracts for the EVM chain (MCT_ERC1155.sol)\n|       |   `-- midnight/     # Compact contracts for the Midnight chain\n|       |\n|       |-- custom-primitive-mct-erc1155/ # Implementation of the custom EVM primitive\n|       |   |-- erc1155-primitive.ts # The class defining the primitive\'s logic\n|       |   `-- erc1155-grammar.ts   # The grammar for the `TransferToMidnight` event\n|       |\n|       `-- data-types/       # Shared configurations and data structures\n|           `-- src/\n|               |-- localhostConfig.ts # **Crucial file**: Defines networks, primitives, etc.\n|               `-- grammar.ts         # Defines the "language" for State Machine inputs\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8959:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/1204-api-07a755ce10451926870ec2b77c5b4f1d.png"}}]);